{
  "code" : "io.liquichain.api.core.LiquichainTransaction",
  "description" : "perform transaction from internal accounts",
  "inputs" : [ {
    "name" : "fromAddress",
    "type" : "String"
  }, {
    "name" : "toAddress",
    "type" : "String"
  }, {
    "name" : "value",
    "type" : "String"
  } ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.core;\n\nimport java.math.BigInteger;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.meveo.admin.exception.BusinessException;\nimport org.meveo.api.persistence.CrossStorageApi;\nimport org.meveo.model.customEntities.Transaction;\nimport org.meveo.model.customEntities.Wallet;\nimport org.meveo.model.storage.Repository;\nimport org.meveo.persistence.CrossStorageService;\nimport org.meveo.service.script.Script;\nimport org.meveo.service.storage.RepositoryService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.web3j.crypto.Credentials;\nimport org.web3j.crypto.Hash;\nimport org.web3j.crypto.RawTransaction;\nimport org.web3j.crypto.TransactionEncoder;\nimport org.web3j.utils.Numeric;\n\nimport io.liquichain.core.BlockForgerScript;\n\npublic class LiquichainTransaction extends Script {\n\n    private static final long LIQUICHAIN_CHAINID = 76l; \n    \n    private static final Logger log = LoggerFactory.getLogger(LiquichainTransaction.class);\n\n    private CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\n\n    private static enum BLOCKCHAIN_TYPE {\n        DATABASE,\n        BESU,\n        FABRIC\n    }\n\n    private static final BLOCKCHAIN_TYPE BLOCKCHAIN_BACKEND = BLOCKCHAIN_TYPE.DATABASE;\n\n\n    private String fromAddress;\n    private String toAddress;\n    private String value;\n    private String result;\n    \n    public void setFromAddress(String fromAddress){\n        this.fromAddress=fromAddress;\n    }\n\n    public void setToAddress(String toAddress){\n        this.toAddress=toAddress;\n    }\n\n    public void setValue(String value){\n        this.value=value;\n    }\n\n    public String getResult(){\n        return result;\n    }\n\n    public String transferDB(String fromAddress,String toAddress,BigInteger value) throws Exception {\n        String transactionHash=\"\";\n        Wallet toWallet = crossStorageApi.find(defaultRepo,toAddress, Wallet.class);\n        Wallet fromWallet = crossStorageApi.find(defaultRepo,fromAddress,Wallet.class);\n        if(fromWallet.getPrivateKey()==null){\n            throw new Exception(\"wallet has no private key\");\n        }\n        String privateKey = fromWallet.getPrivateKey();\n        if(privateKey.startsWith(\"0x\")){\n            privateKey = privateKey.substring(2);\n        }\n        BigInteger originBalance = new BigInteger(fromWallet.getBalance());\n        log.info(\"originWallet 0x{} old balance:{} amount:{}\",fromAddress,fromWallet.getBalance(),value);\n        if(value.compareTo(originBalance)>0){\n            throw new  BusinessException (\"Insufficient balance\");\n        }\n        \n        List<Transaction> walletTransactions = crossStorageApi.find(defaultRepo, Transaction.class).by(\"fromHexHash\", fromWallet.getUuid()).getResults();\n        BigInteger nonce= BigInteger.ONE;\n        if(walletTransactions!=null && walletTransactions.size()>0){\n            walletTransactions.sort(Comparator.comparing(Transaction::getNonce).reversed());\n            Transaction lastTransaction = walletTransactions.get(0);\n            try{\n                nonce=BigInteger.valueOf(Long.parseLong(lastTransaction.getNonce())+1);\n            } catch(Exception e){\n                log.error(\"invalid nonce :{}\",lastTransaction.getNonce());\n            }\n        }\n        String recipientAddress = \"0x\"+toWallet.getUuid();\n        BigInteger gasLimit = BigInteger.ZERO;\n        BigInteger gasPrice = BigInteger.ZERO;\n        RawTransaction rawTransaction = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit,recipientAddress, value);\n        Credentials credentials = Credentials.create(privateKey);\n        byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\n        String hexValue = Numeric.toHexString(signedMessage);\n        \n        Transaction transac = new Transaction();\n        transactionHash=Hash.sha3(hexValue);\n        transac.setHexHash(transactionHash);\n        transac.setFromHexHash(fromWallet.getUuid());\n        transac.setToHexHash(toWallet.getUuid());\n        transac.setNonce(\"\"+nonce);\n        transac.setGasPrice(\"0\");\n        transac.setGasLimit(\"0\");\n        transac.setValue(\"\"+value);\n      \n        transac.setSignedHash(hexValue);\n      \n        transac.setCreationDate(java.time.Instant.now());\n        \n        crossStorageApi.createOrUpdate(defaultRepo, transac);\n        //FIXME: you should get the BlockForgerScript from scriptService\n        \n        BlockForgerScript.addTransaction(transac);\n        return transactionHash;\n    }\n\n    private String transferBesu(String fromAddress,String toAddress,BigInteger amount) throws Exception {\n        return \"\";\n    }\n\n    private String transferFabric(String fromAddress,String toAddress,BigInteger amount)  throws Exception {\n        return \"\";\n    }\n\n    public String transfer(String fromAddress,String toAddress,BigInteger amount) throws Exception{\n        String transactionHash = \"\";\n        switch (BLOCKCHAIN_BACKEND){\n            case BESU:\n                transactionHash = transferBesu(fromAddress,toAddress,amount);\n                break;\n            case FABRIC:\n                transactionHash = transferFabric(fromAddress,toAddress,amount);\n                break;\n            default:\n                transactionHash = transferDB(fromAddress,toAddress,amount);\n                break;\n        }\n        return transactionHash;\n    }\n\n    //used to transfer from local account\n    @Override\n    public void execute(Map<String, Object> parameters) throws BusinessException {\n        String transactionHash = \"\";\n        try{\n            transactionHash =  transfer(fromAddress,toAddress,new BigInteger(value));\n            result = \"{\\\"transaction_hash\\\":\\\"\"+transactionHash+\"\\\"}\";\n        } catch (Exception e){\n            log.error(\" transafer error\", e);\n            result = \"{\\\"error\\\":\\\"\"+e.getMessage()+\"\\\"}\";\n        }\n    }\n\n}\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ ],
  "importScriptInstances" : [ {
    "code" : "io.liquichain.core.BlockForgerScript",
    "description" : "Bock forging script",
    "inputs" : [ ],
    "outputs" : [ {
      "name" : "lastBlock",
      "type" : "Block"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package io.liquichain.core;\n\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.math.BigInteger;\nimport java.time.Instant;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\nimport java.io.IOException;\nimport org.meveo.service.script.Script;\nimport org.meveo.admin.exception.BusinessException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.math.BigInteger;\nimport org.meveo.model.customEntities.Block;\nimport org.meveo.model.customEntities.Wallet;\nimport org.meveo.model.customEntities.Transaction;\nimport org.meveo.model.storage.Repository;\nimport org.meveo.service.storage.RepositoryService;\nimport org.meveo.api.persistence.CrossStorageApi;\nimport org.meveo.persistence.CrossStorageService;\nimport org.meveo.cache.CustomFieldsCacheContainerProvider;\nimport org.meveo.api.exception.EntityDoesNotExistsException;\nimport org.meveo.admin.util.pagination.PaginationConfiguration;\nimport org.meveo.model.persistence.CEIUtils;\nimport org.meveo.service.custom.CustomTableService;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.primefaces.model.SortOrder;\n\nimport org.web3j.crypto.*;\n\npublic class BlockForgerScript extends Script {\n\n    private static final Logger log = LoggerFactory.getLogger(BlockForgerScript.class);\n  \n    private static long chainId=76;\n\n    private int networkId = 7;\n\n    static public long blockHeight = 1662295;\n  \n    private Block parentBlock=null;\n    \n    private String exampleBlock = \"{\" +\n      \"\\\"difficulty\\\":\\\"0x5\\\",\" +\n      \"\\\"extraData\\\":\\\"0xd58301090083626f7286676f312e3133856c696e75780000000000000000000021c9effaf6549e725463c7877ddebe9a2916e03228624e4bfd1e3f811da792772b54d9e4eb793c54afb4a29f014846736755043e4778999046d0577c6e57e72100\\\",\"\n      + \"\\\"gasLimit\\\":\\\"0xe984c2\\\",\" + \"\\\"gasUsed\\\":\\\"0x0\\\",\" \n      + \"\\\"hash\\\":\\\"0xaa14340feb15e26bc354bb839b2aa41cc7984676249c155ac5e4d281a8d08809\\\",\"\n      + \"\\\"logsBloom\\\":\\\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\\",\"\n      + \"\\\"miner\\\":\\\"0x0000000000000000000000000000000000000000\\\",\" +\n      \"\\\"mixHash\\\":\\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\",\" +\n      \"\\\"nonce\\\":\\\"0x0000000000000000\\\",\" +\n      \"\\\"number\\\":\\\"0x1b4\\\",\" +\n      \"\\\"parentHash\\\":\\\"0xc8ccb81f484a428a3a1669d611f55f880b362b612f726711947d98f5bc5af573\\\",\" + \n      \"\\\"receiptsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" +\n      \"\\\"sha3Uncles\\\":\\\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\\\",\" +\n      \"\\\"size\\\":\\\"0x260\\\",\" +\n      \"\\\"stateRoot\\\":\\\"0xffcb834d62706995e9e7bf10cc9a9e42a82fea998d59b3a5cfad8975dbfe3f87\\\",\" +\n      \"\\\"timestamp\\\":\\\"0x5ed9a43f\\\",\" +\n      \"\\\"totalDifficulty\\\":\\\"0x881\\\",\" +\n      \"\\\"transactions\\\":[\" + \"],\" + \n      \"\\\"transactionsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" + \n      \"\\\"uncles\\\":[  \" + \"]}\";\n\n      \n\tprivate CustomFieldsCacheContainerProvider cetCache = getCDIBean(CustomFieldsCacheContainerProvider.class);\n    private CrossStorageService crossStorageService = getCDIBean(CrossStorageService.class);\n    private CustomTableService customTableService = getCDIBean(CustomTableService.class);\n    \n    private static PaginationConfiguration lastBlockPC = new PaginationConfiguration(\"blockNumber\",SortOrder.DESCENDING);\n  \n  \tprivate CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\n\n    \n    private static List<Transaction> currentTransactions = new ArrayList<>();\n    private static List<Transaction> nextTransactions = new ArrayList<>();\n  \n    private static Instant nextBlockDate;\n    private static AtomicBoolean isForging = new AtomicBoolean(false);\n  \n    public static void addTransaction(Transaction t){\n      if(isForging.get()){\n          nextTransactions.add(t);\n      } else {\n          currentTransactions.add(t);\n      }\n    }\n  \n    public Block getLastBlock(){\n        Block result = null;\n        try{\n            //log.info(\"query : \"+customTableService.getQuery(\"block\", lastBlockPC));\n        List<Map<String, Object>> res = crossStorageService.find(defaultRepo, cetCache.getCustomEntityTemplate(\"Block\"), lastBlockPC);\n        if(res.size()>0){\n            result = CEIUtils.deserialize(res.get(0), Block.class);\n            log.info(\"lastBlock number:{}\",result.getBlockNumber());\n        }\n        } catch(Exception e){\n          log.error(\"getLastBlock:{}\",e);\n        }\n        return result;\n    }\n  \n    @Override\n    public void execute(Map<String, Object> parameters) throws BusinessException {\n      //log.info(\"execute forging\");\n      if(parentBlock==null){\n      \t//log.info(\"retreive last block from chain\");\n        parentBlock = getLastBlock();\n      }\n      if(isForging.getAndSet(true)){\n         log.error(\"we are already forging\");\n         return;\n      } \n      if(currentTransactions.size()==0){\n        log.info(\"no transaction to forge\");\n        isForging.set(false);\n        return;\n      } else {\n        log.info(\"forging {} transactions\",currentTransactions.size());\n        Map<String,Wallet> wallets = new HashMap<>();\n        List<Transaction> orderedTransactions = currentTransactions.stream().sorted((t1,t2)->(t1.getCreationDate().compareTo(t2.getCreationDate()))).collect(Collectors.toList());\n        \n        blockHeight=parentBlock.getBlockNumber()+1;\n        \n        String transactionHashes=\"\";\n        List<Transaction> invalidTransactions = new ArrayList<>();\n        for(Transaction t: currentTransactions){\n          log.info(\" transaction date : {}\",t.getCreationDate());\n          if(!wallets.containsKey(t.getFromHexHash())){\n            try{\n            \tWallet originWallet = crossStorageApi.find(defaultRepo,t.getFromHexHash(), Wallet.class);\n                log.info(\"add originWallet:{} {} to map\",originWallet.getUuid(),originWallet.getBalance());\n                wallets.put(t.getFromHexHash(),originWallet);\n            } catch(Exception e){\n              log.info(\" cannot find origin wallet, set blockNumber to INVALID\");\n              t.setBlockNumber(\"INVALID\");\n              try {\n              crossStorageApi.createOrUpdate(defaultRepo, t);\n              } catch(Exception ex){\n                ex.printStackTrace();\n              }\n              invalidTransactions.add(t);\n            }\n          }\n          if(t.getBlockNumber() == null){\n            Wallet originWallet = wallets.get(t.getFromHexHash());\n          \tlog.info(\"originWallet 0x{} old balance:{}\",t.getFromHexHash(),originWallet.getBalance());\n            BigInteger transacValue = new BigInteger(t.getValue());\n          \tif(new BigInteger(originWallet.getBalance()).compareTo(transacValue)>=0){\n                originWallet.setBalance(\"\"+new BigInteger(originWallet.getBalance()).add(transacValue.negate()));\n                try{\n            \t\tWallet destinationWallet = crossStorageApi.find(defaultRepo,t.getToHexHash(), Wallet.class);\n          \t\t\tlog.info(\"destinationWallet 0x{} old balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\n                    destinationWallet.setBalance(\"\"+new BigInteger(destinationWallet.getBalance()).add(transacValue));\n          \t\t\tcrossStorageApi.createOrUpdate(defaultRepo, destinationWallet);\n          \t\t\tlog.info(\"destinationWallet 0x{} new balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\n          \t\t\ttransactionHashes+=t.getHexHash();\n                } catch(Exception e){\n              \t\tlog.info(\" cannot find destination wallet, set blockNumber to INVALID\");\n              \t\tt.setBlockNumber(\"INVALID\");\n              \t\ttry{\n\t\t\t\t\t\tcrossStorageApi.createOrUpdate(defaultRepo, t);\n                    } catch(Exception ex){\n                \t\tex.printStackTrace();\n              \t\t}\n              \t\tinvalidTransactions.add(t);\n                }\n          \t} else {\n              log.info(\"insufficient balance, set blockNumber to INVALID\");\n              t.setBlockNumber(\"INVALID\");\n              try{\n              \tcrossStorageApi.createOrUpdate(defaultRepo, t);\n              } catch(Exception ex){\n                ex.printStackTrace();\n              }\n              invalidTransactions.add(t);\n            }\n          }\n        }\n        currentTransactions.removeAll(invalidTransactions);\n        Block block =  new Block();\n        block.setCreationDate(Instant.now());\n        \n        //FIXME parent should not be null\n        block.setParentHash(parentBlock==null?\"\":parentBlock.getHash());\n        block.setSize((long)currentTransactions.size());\n        \n        //FIXME hash parent hash\n        block.setHash(Hash.sha3(transactionHashes).substring(2));\n        \n        block.setBlockNumber(blockHeight);\n        try{\n          crossStorageApi.createOrUpdate(defaultRepo, block);\n          long i=0;\n          for(Transaction t: currentTransactions){\n              Wallet originWallet = wallets.get(t.getFromHexHash());\n              log.info(\"originWallet 0x{} new balance:{}\",t.getFromHexHash(),originWallet.getBalance());\n              crossStorageApi.createOrUpdate(defaultRepo, originWallet);\n              t.setBlockHash(block.getHash());\n              t.setBlockNumber(\"\"+block.getBlockNumber());\n              t.setTransactionIndex(i++);\n              crossStorageApi.createOrUpdate(defaultRepo, t);\n          }\n\n          parentBlock=block;\n          currentTransactions = nextTransactions;\n          nextTransactions = new ArrayList<>();\n        } catch(Exception ex){\n            ex.printStackTrace();\n        }\n        \n        isForging.set(false);\n      }\n    }\n  \n}\n",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ {
      "groupId" : "org.web3j",
      "artifactId" : "crypto",
      "version" : "4.8.9",
      "coordinates" : "org.web3j:crypto:4.8.9"
    } ],
    "importScriptInstances" : [ ]
  } ]
}