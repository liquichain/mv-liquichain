{
  "code" : "io.liquichain.api.core.LiquichainTransaction",
  "description" : "perform transaction from internal accounts",
  "inputs" : [ {
    "name" : "fromAddress",
    "type" : "String"
  }, {
    "name" : "toAddress",
    "type" : "String"
  }, {
    "name" : "value",
    "type" : "String"
  } ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.core;\n\nimport static org.web3j.protocol.core.DefaultBlockParameterName.LATEST;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport org.meveo.admin.exception.BusinessException;\nimport org.meveo.api.persistence.CrossStorageApi;\nimport org.meveo.commons.utils.ParamBean;\nimport org.meveo.commons.utils.ParamBeanFactory;\nimport org.meveo.model.customEntities.Transaction;\nimport org.meveo.model.customEntities.Wallet;\nimport org.meveo.model.storage.Repository;\nimport org.meveo.service.script.Script;\nimport org.meveo.service.storage.RepositoryService;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.ws.rs.client.*;\nimport javax.ws.rs.core.*;\n\nimport org.web3j.abi.datatypes.Address;\nimport org.web3j.abi.datatypes.Bool;\nimport org.web3j.abi.datatypes.Function;\nimport org.web3j.abi.datatypes.generated.Uint256;\nimport org.web3j.abi.FunctionEncoder;\nimport org.web3j.abi.TypeReference;\nimport org.web3j.crypto.Credentials;\nimport org.web3j.crypto.Hash;\nimport org.web3j.crypto.RawTransaction;\nimport org.web3j.crypto.TransactionEncoder;\nimport org.web3j.protocol.Web3j;\nimport org.web3j.protocol.core.methods.response.EthGetBalance;\nimport org.web3j.protocol.core.methods.response.EthGetTransactionCount;\nimport org.web3j.protocol.core.methods.response.EthGetTransactionReceipt;\nimport org.web3j.protocol.core.methods.response.EthSendTransaction;\nimport org.web3j.protocol.core.methods.response.TransactionReceipt;\nimport org.web3j.protocol.exceptions.ClientConnectionException;\nimport org.web3j.protocol.Service;\nimport org.web3j.tx.RawTransactionManager;\nimport org.web3j.utils.Convert;\nimport org.web3j.utils.Convert.Unit;\nimport org.web3j.utils.Numeric;\n\nimport org.meveo.firebase.CloudMessaging;\nimport io.liquichain.core.BlockForgerScript;\n\npublic class LiquichainTransaction extends Script {\n    private static final Logger LOG = LoggerFactory.getLogger(LiquichainTransaction.class);\n    private static final int SLEEP_DURATION = 15000;\n    private static final int ATTEMPTS = 40;\n    private static final String INSUFFICIENT_BALANCE = \"Insufficient balance\";\n    private static final String TRANSACTION_FAILED = \"Transaction failed\";\n    private static final String TRANSACTION_DATA_FORMAT = \"{\\\"type\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\"}\";\n\n    private CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\n    private ParamBeanFactory paramBeanFactory = getCDIBean(ParamBeanFactory.class);\n    private ParamBean config = paramBeanFactory.getInstance();\n    private String besuApiUrl = config\n            .getProperty(\"besu.api.url\", \"https://testnet.liquichain.io/rpc\");\n    private BigInteger defaultGasLimit =\n            new BigInteger(config.getProperty(\"besu.gas.limit\", \"120000\"));\n    private BigInteger defaultGasPrice = new BigInteger(config.getProperty(\"besu.gas.price\", \"0\"));\n    private String smartContract = config\n            .getProperty(\"besu.smart.contract\", \"0x0Cd07348D582a6F4A3641D3192f1f467586BE990\");\n\n    private Web3j web3j = Web3j.build(new HttpService(besuApiUrl));\n\n    private enum BLOCKCHAIN_TYPE {DATABASE, BESU_ONLY, FABRIC, BESU}\n\n    private String blockchainType = config.getProperty(\"txn.blockchain.type\", \"BESU\");\n    private BLOCKCHAIN_TYPE BLOCKCHAIN_BACKEND = BLOCKCHAIN_TYPE.valueOf(blockchainType);\n\n    private CloudMessaging cloudMessaging = new CloudMessaging();\n\n    private String fromAddress;\n    private String toAddress;\n    private String value;\n    private String result;\n\n    public void setFromAddress(String fromAddress) {\n        this.fromAddress = fromAddress;\n    }\n\n    public void setToAddress(String toAddress) {\n        this.toAddress = toAddress;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    public String getResult() {\n        return result;\n    }\n\n    private String normalizeHash(String hash) {\n        if (hash.startsWith(\"0x\")) {\n            return hash.substring(2);\n        }\n        return hash;\n    }\n\n    private String toHexHash(String hash) {\n        if (hash.startsWith(\"0x\")) {\n            return hash;\n        }\n        return \"0x\" + hash;\n    }\n\n    private Optional<TransactionReceipt> sendTransactionReceiptRequest(String transactionHash)\n            throws Exception {\n        EthGetTransactionReceipt transactionReceipt = web3j\n                .ethGetTransactionReceipt(transactionHash)\n                .sendAsync()\n                .get();\n\n        return transactionReceipt.getTransactionReceipt();\n    }\n\n    private Optional<TransactionReceipt> getTransactionReceipt(\n            String transactionHash, int sleepDuration, int attempts) throws Exception {\n        Optional<TransactionReceipt> receiptOptional =\n                sendTransactionReceiptRequest(transactionHash);\n        for (int i = 0; i < attempts; i++) {\n            if (!receiptOptional.isPresent()) {\n                Thread.sleep(sleepDuration);\n                receiptOptional = sendTransactionReceiptRequest(transactionHash);\n            } else {\n                break;\n            }\n        }\n        return receiptOptional;\n    }\n\n    private TransactionReceipt waitForTransactionReceipt(String transactionHash) throws Exception {\n        Optional<TransactionReceipt> transactionReceiptOptional =\n                getTransactionReceipt(transactionHash, SLEEP_DURATION, ATTEMPTS);\n\n        if (!transactionReceiptOptional.isPresent()) {\n            throw new BusinessException(\n                    \"Transaction receipt not generated after \" + ATTEMPTS + \" attempts\");\n        }\n        return transactionReceiptOptional.get();\n    }\n\n    private void updateWalletBalances(String from, String to) throws Exception {\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, from, Wallet.class);\n        Wallet toWallet = crossStorageApi.find(defaultRepo, to, Wallet.class);\n\n        EthGetBalance toBalance = web3j.ethGetBalance(to, LATEST).sendAsync().get();\n        EthGetBalance fromBalance = web3j.ethGetBalance(from, LATEST).sendAsync().get();\n\n        fromWallet.setBalance(fromBalance.getBalance().toString());\n        toWallet.setBalance(toBalance.getBalance().toString());\n        crossStorageApi.createOrUpdate(defaultRepo, fromWallet);\n        crossStorageApi.createOrUpdate(defaultRepo, toWallet);\n    }\n\n    private String transferDB(String from, String to, BigInteger amount, String type,\n                              String description) throws Exception {\n        String transactionHash = \"\";\n        Wallet toWallet = crossStorageApi.find(defaultRepo, to, Wallet.class);\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, from, Wallet.class);\n        if (fromWallet.getPrivateKey() == null) {\n            throw new Exception(\"wallet has no private key\");\n        }\n        String privateKey = normalizeHash(fromWallet.getPrivateKey());\n\n        BigInteger originBalance = new BigInteger(fromWallet.getBalance());\n        if (amount.compareTo(originBalance) > 0) {\n            throw new BusinessException(INSUFFICIENT_BALANCE);\n        }\n\n        Transaction lastTransaction = crossStorageApi.find(defaultRepo, Transaction.class)\n                                                     .by(\"fromHexHash\", fromWallet.getUuid())\n                                                     .orderBy(\"nonce\", false) // by largest to smallest\n                                                     .getResult();\n        BigInteger nonce = BigInteger.ONE;\n        if (lastTransaction != null) {\n            try {\n                nonce = BigInteger.valueOf(Long.parseLong(lastTransaction.getNonce()) + 1);\n            } catch (NumberFormatException e) {\n                LOG.error(\"invalid nonce :{}\", lastTransaction.getNonce());\n            }\n        }\n\n        String recipientAddress = \"0x\" + toWallet.getUuid();\n        String data = String.format(TRANSACTION_DATA_FORMAT, type, description);\n        BigInteger gasLimit = BigInteger.ZERO;\n        BigInteger gasPrice = BigInteger.ZERO;\n        RawTransaction rawTransaction = RawTransaction\n                .createTransaction(nonce, gasPrice, gasLimit, recipientAddress, amount, data);\n        Credentials credentials = Credentials.create(privateKey);\n        byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\n        String encodedTransaction = Numeric.toHexString(signedMessage);\n\n        Transaction transaction = new Transaction();\n        transactionHash = Hash.sha3(encodedTransaction);\n        transaction.setHexHash(normalizeHash(transactionHash));\n        transaction.setFromHexHash(fromWallet.getUuid());\n        transaction.setToHexHash(toWallet.getUuid());\n        transaction.setNonce(\"\" + nonce);\n        transaction.setGasPrice(gasPrice.toString());\n        transaction.setGasLimit(gasLimit.toString());\n        transaction.setValue(amount.toString());\n        transaction.setData(data);\n        transaction.setType(type);\n        transaction.setSignedHash(normalizeHash(encodedTransaction));\n        transaction.setCreationDate(java.time.Instant.now());\n\n        crossStorageApi.createOrUpdate(defaultRepo, transaction);\n\n        // FIXME: you should get the BlockForgerScript from scriptService\n        BlockForgerScript.addTransaction(transaction);\n\n        return transactionHash;\n    }\n\n    private String transferBesu(String from, String to, BigInteger amount,\n                                String type, String description) throws Exception {\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, from, Wallet.class);\n        String privateKey = fromWallet.getPrivateKey();\n        BigInteger balance = BigInteger.ZERO;\n\n        if (fromWallet.getBalance() == null || fromWallet.getBalance().isEmpty()) {\n            balance = web3j.ethGetBalance(from, LATEST).sendAsync().get().getBalance();\n\n        } else {\n            balance = new BigInteger(fromWallet.getBalance());\n        }\n\n        if (balance.compareTo(amount) < 0) {\n            throw new BusinessException(INSUFFICIENT_BALANCE);\n        }\n\n        Credentials credentials = Credentials.create(privateKey);\n        EthGetTransactionCount ethGetTransactionCount = web3j\n                .ethGetTransactionCount(credentials.getAddress(), LATEST)\n                .send();\n        BigInteger nonce = ethGetTransactionCount.getTransactionCount();\n\n        org.web3j.protocol.core.methods.request.Transaction transaction =\n                org.web3j.protocol.core.methods.request.Transaction\n                        .createEtherTransaction(from, nonce, defaultGasPrice,\n                                                defaultGasLimit, to, amount);\n\n        BigInteger estimatedGas = web3j.ethEstimateGas(transaction).send().getAmountUsed();\n        LOG.debug(\"estimatedGas: {}\", estimatedGas);\n        BigInteger gasPrice = web3j.ethGasPrice().send().getGasPrice();\n        LOG.debug(\"gasPrice: {}\", gasPrice);\n\n        RawTransaction rawTransaction = RawTransaction\n                .createEtherTransaction(nonce, gasPrice, defaultGasLimit, to, amount);\n\n        byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\n        String encodedTransaction = Numeric.toHexString(signedMessage);\n\n        EthSendTransaction ethSendTransaction = web3j\n                .ethSendRawTransaction(encodedTransaction)\n                .sendAsync()\n                .get();\n\n        String transactionHash = ethSendTransaction.getTransactionHash();\n        LOG.debug(\"pending transactionHash: {}\", transactionHash);\n\n        if (transactionHash == null || transactionHash.isEmpty()) {\n            throw new BusinessException(TRANSACTION_FAILED);\n        }\n\n        TransactionReceipt transactionReceipt = waitForTransactionReceipt(transactionHash);\n\n        String completedTransactionHash = transactionReceipt.getTransactionHash();\n        LOG.debug(\"completed transactionHash: {}\", completedTransactionHash);\n\n        updateWalletBalances(from, to);\n\n        return completedTransactionHash;\n    }\n\n    private String transferBesuDB(String from, String to, BigInteger amount,\n                                  String type, String description) throws Exception {\n\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, from, Wallet.class);\n        Wallet toWallet = crossStorageApi.find(defaultRepo, to, Wallet.class);\n\n        String privateKey = fromWallet.getPrivateKey();\n        BigInteger balance = BigInteger.ZERO;\n\n        if (fromWallet.getBalance() == null || fromWallet.getBalance().isEmpty()) {\n            balance = web3j.ethGetBalance(from, LATEST).sendAsync().get().getBalance();\n\n        } else {\n            balance = new BigInteger(fromWallet.getBalance());\n        }\n\n        if (balance.compareTo(amount) < 0) {\n            throw new BusinessException(INSUFFICIENT_BALANCE);\n        }\n\n        Credentials credentials = Credentials.create(privateKey);\n        EthGetTransactionCount ethGetTransactionCount = web3j\n                .ethGetTransactionCount(credentials.getAddress(), LATEST)\n                .send();\n        BigInteger nonce = ethGetTransactionCount.getTransactionCount();\n\n        BigInteger gasPrice = web3j.ethGasPrice().send().getGasPrice();\n        LOG.debug(\"gasPrice: {}\", gasPrice);\n\n        RawTransaction rawTransaction = RawTransaction\n                .createEtherTransaction(nonce, gasPrice, defaultGasLimit, to, amount);\n        byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\n        String encodedTransaction = Numeric.toHexString(signedMessage);\n\n        EthSendTransaction ethSendTransaction = web3j\n                .ethSendRawTransaction(encodedTransaction)\n                .sendAsync()\n                .get();\n\n        String transactionHash = ethSendTransaction.getTransactionHash();\n        LOG.debug(\"pending transactionHash: {}\", transactionHash);\n\n        if (transactionHash == null || transactionHash.isEmpty()) {\n            throw new BusinessException(TRANSACTION_FAILED);\n        }\n\n        TransactionReceipt transactionReceipt = waitForTransactionReceipt(transactionHash);\n\n        String completedTransactionHash = transactionReceipt.getTransactionHash();\n        LOG.debug(\"completed transactionHash: {}\", completedTransactionHash);\n\n        String data = String.format(TRANSACTION_DATA_FORMAT, type, description);\n\n        Transaction transaction = new Transaction();\n        transaction.setHexHash(normalizeHash(completedTransactionHash));\n        transaction.setFromHexHash(fromWallet.getUuid());\n        transaction.setToHexHash(toWallet.getUuid());\n        transaction.setNonce(\"\" + nonce);\n        transaction.setGasPrice(gasPrice.toString());\n        transaction.setGasLimit(defaultGasLimit.toString());\n        transaction.setValue(amount.toString());\n        transaction.setData(data);\n        transaction.setType(type);\n        transaction.setSignedHash(normalizeHash(encodedTransaction));\n        transaction.setCreationDate(java.time.Instant.now());\n\n        crossStorageApi.createOrUpdate(defaultRepo, transaction);\n\n        updateWalletBalances(from, to);\n\n        return completedTransactionHash;\n    }\n\n    public String transferSmartContract(String from, String to, BigInteger amount,\n                                         String type, String description, String message) throws Exception {\n        String sender = normalizeHash(from);\n        String recipient = normalizeHash(to);\n\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, sender, Wallet.class);\n        Wallet toWallet = crossStorageApi.find(defaultRepo, recipient, Wallet.class);\n        String privateKey = fromWallet.getPrivateKey();\n        Credentials credentials = Credentials.create(privateKey);\n        BigInteger balance = BigInteger.ZERO;\n\n        LOG.info(\"transfer amount:{} to:{}\", amount, toHexHash(to));\n        RawTransactionManager manager = new RawTransactionManager(web3j, credentials);\n        Function function = new Function(\n                \"transfer\",\n                Arrays.asList(new Address(toHexHash(to)), new Uint256(amount)),\n                Arrays.asList(new TypeReference<Bool>() {}));\n        String data = FunctionEncoder.encode(function);\n\n        BigInteger gasPrice = BigInteger.ZERO;\n        EthSendTransaction sendTransaction = manager.sendTransaction(\n                gasPrice,\n                defaultGasLimit,\n                smartContract,\n                data,\n                null);\n        String transactionHash = sendTransaction.getTransactionHash();\n        LOG.info(\"pending transactionHash: {}\", transactionHash);\n\n        if (transactionHash == null || transactionHash.isEmpty()) {\n            throw new BusinessException(TRANSACTION_FAILED);\n        }\n\n        TransactionReceipt transactionReceipt = waitForTransactionReceipt(transactionHash);\n\n        String completedTransactionHash = transactionReceipt.getTransactionHash();\n        LOG.info(\"completed transactionHash: {}\", completedTransactionHash);\n\n        EthGetTransactionCount ethGetTransactionCount = web3j\n                .ethGetTransactionCount(credentials.getAddress(), LATEST)\n                .send();\n        BigInteger nonce = ethGetTransactionCount.getTransactionCount();\n\n        RawTransaction rawTransaction = RawTransaction\n                .createEtherTransaction(nonce, gasPrice, defaultGasLimit, to, amount);\n        byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\n        String encodedTransaction = Numeric.toHexString(signedMessage);\n\n        String transactionData = String.format(TRANSACTION_DATA_FORMAT, type, description);\n\n        Transaction transaction = new Transaction();\n        transaction.setHexHash(normalizeHash(completedTransactionHash));\n        transaction.setFromHexHash(fromWallet.getUuid());\n        transaction.setToHexHash(toWallet.getUuid());\n        transaction.setNonce(\"\" + nonce);\n        transaction.setGasPrice(gasPrice.toString());\n        transaction.setGasLimit(defaultGasLimit.toString());\n        transaction.setValue(amount.toString());\n        transaction.setData(transactionData);\n        transaction.setType(type);\n        transaction.setSignedHash(normalizeHash(encodedTransaction));\n        transaction.setCreationDate(java.time.Instant.now());\n\n        crossStorageApi.createOrUpdate(defaultRepo, transaction);\n\n        updateWalletBalances(sender, recipient);\n        \n        try {\n            if (!completedTransactionHash.isEmpty()) {\n                cloudMessaging.setUserId(recipient);\n                cloudMessaging.setTitle(\"Telecel Play\");\n                cloudMessaging.setBody(message);\n                cloudMessaging.execute(null);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"cannot send notification to {}: {}\", to, message);\n        }\n\n        return completedTransactionHash;\n    }\n\n    private String transferFabric(String from, String to, BigInteger amount,\n                                  String type, String description) throws Exception {\n        return \"\";\n    }\n\n    public String transfer(String from, String to, BigInteger amount)\n            throws Exception {\n        String message = String.format(\n                \"You received %s coins !\",\n                Convert.fromWei(amount.toString(), Unit.ETHER));\n        return transfer(from, to, amount, \"transfer\", \"Transfer coins\", message);\n    }\n\n    public String transfer(String from, String to, BigInteger amount, String type,\n                           String description, String message) throws Exception {\n        String transactionHash = \"\";\n        String recipientAddress = normalizeHash(to);\n        String senderAddress = normalizeHash(from);\n        switch (BLOCKCHAIN_BACKEND) {\n            case BESU_ONLY:\n                transactionHash = transferBesu(\n                        senderAddress,\n                        recipientAddress,\n                        amount,\n                        type,\n                        description);\n                break;\n            case FABRIC:\n                transactionHash = transferFabric(\n                        senderAddress,\n                        recipientAddress,\n                        amount,\n                        type,\n                        description);\n                break;\n            case BESU:\n                transactionHash = transferBesuDB(\n                        from,\n                        to,\n                        amount,\n                        type,\n                        description);\n                break;\n            default:\n                transactionHash = transferDB(\n                        senderAddress,\n                        recipientAddress,\n                        amount,\n                        type,\n                        description);\n                break;\n        }\n        // TODO - send notification to the user e.g. CloudMessaging\n        try {\n            if (!transactionHash.isEmpty()) {\n                cloudMessaging.setUserId(recipientAddress);\n                cloudMessaging.setTitle(\"Telecel Play\");\n                cloudMessaging.setBody(message);\n                cloudMessaging.execute(null);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"cannot send notification to {}: {}\", recipientAddress, message);\n        }\n        return transactionHash;\n    }\n\n    // used to transfer from local account\n    @Override\n    public void execute(Map<String, Object> parameters) throws BusinessException {\n        String transactionHash = \"\";\n        try {\n            transactionHash = transfer(fromAddress, toAddress, new BigInteger(value));\n            result = \"{\\\"transaction_hash\\\":\\\"\" + transactionHash + \"\\\"}\";\n        } catch (Exception e) {\n            LOG.error(\"Transfer error\", e);\n            result = \"{\\\"error\\\":\\\"\" + e.getMessage() + \"\\\"}\";\n        }\n    }\n}\n\nclass HttpService extends Service {\n\n    public static final String DEFAULT_URL = \"http://localhost:8545/\";\n    private static final Logger LOG = LoggerFactory.getLogger(HttpService.class);\n\n    private Client httpClient;\n    private final String url;\n    private final boolean includeRawResponse;\n    private Map<String, String> headers = new HashMap<>();\n\n    public HttpService(String url, Client httpClient, boolean includeRawResponse) {\n        super(includeRawResponse);\n        this.url = url;\n        this.httpClient = httpClient;\n        this.includeRawResponse = includeRawResponse;\n    }\n\n    public HttpService(Client httpClient, boolean includeRawResponse) {\n        this(DEFAULT_URL, httpClient, includeRawResponse);\n    }\n\n    public HttpService(String url, Client httpClient) {\n        this(url, httpClient, false);\n    }\n\n    public HttpService(String url) {\n        this(url, createHttpClient());\n    }\n\n    public HttpService(String url, boolean includeRawResponse) {\n        this(url, createHttpClient(), includeRawResponse);\n    }\n\n    public HttpService(Client httpClient) {\n        this(DEFAULT_URL, httpClient);\n    }\n\n    public HttpService(boolean includeRawResponse) {\n        this(DEFAULT_URL, includeRawResponse);\n    }\n\n    public HttpService() {\n        this(DEFAULT_URL);\n    }\n\n    private static Client createHttpClient() {\n        return ClientBuilder.newClient();\n    }\n\n    @Override\n    protected InputStream performIO(String request) throws IOException {\n\n        LOG.debug(\"Request: {}\", request);\n\n        Response response = null;\n        try {\n            response = httpClient.target(url)\n                                 .request(MediaType.APPLICATION_JSON)\n                                 .headers(convertHeaders())\n                                 .post(Entity.json(request));\n        } catch (ClientConnectionException e) {\n            throw new IOException(\"Unable to connect to \" + url, e);\n        }\n\n        if (response.getStatus() != 200) {\n            throw new IOException(\n                    \"Error \" + response.getStatus() + \": \" + response.readEntity(String.class));\n        }\n\n        if (includeRawResponse) {\n            return new BufferedInputStream(response.readEntity(InputStream.class));\n        }\n\n        return new ByteArrayInputStream(response.readEntity(String.class).getBytes());\n    }\n\n    private MultivaluedMap<String, Object> convertHeaders() {\n        MultivaluedMap<String, Object> headers = new MultivaluedHashMap<>();\n        for (Map.Entry<String, String> entry : this.headers.entrySet()) {\n            headers.put(entry.getKey(), Arrays.asList(entry.getValue()));\n        }\n        return headers;\n    }\n\n    public void addHeader(String key, String value) {\n        headers.put(key, value);\n    }\n\n    public void addHeaders(Map<String, String> headersToAdd) {\n        headers.putAll(headersToAdd);\n    }\n\n    public Map<String, String> getHeaders() {\n        return headers;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    @Override\n    public void close() throws IOException {}\n\n}\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ {
    "groupId" : "org.web3j",
    "artifactId" : "core",
    "version" : "4.8.9",
    "coordinates" : "org.web3j:core:4.8.9"
  } ],
  "importScriptInstances" : [ {
    "code" : "io.liquichain.core.BlockForgerScript",
    "description" : "Bock forging script",
    "inputs" : [ ],
    "outputs" : [ {
      "name" : "lastBlock",
      "type" : "Block"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package io.liquichain.core;\r\n\r\nimport java.util.Map;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Arrays;\r\nimport java.util.ArrayList;\r\nimport java.math.BigInteger;\r\nimport java.time.Instant;\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\nimport java.util.stream.Collectors;\r\nimport java.io.IOException;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.math.BigInteger;\r\nimport org.meveo.model.customEntities.Block;\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.customEntities.Transaction;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.persistence.CrossStorageService;\r\nimport org.meveo.cache.CustomFieldsCacheContainerProvider;\r\nimport org.meveo.api.exception.EntityDoesNotExistsException;\r\nimport org.meveo.admin.util.pagination.PaginationConfiguration;\r\nimport org.meveo.model.persistence.CEIUtils;\r\nimport org.meveo.service.custom.CustomTableService;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.primefaces.model.SortOrder;\r\n\r\nimport org.web3j.crypto.*;\r\n\r\npublic class BlockForgerScript extends Script {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(BlockForgerScript.class);\r\n  \r\n    private static long chainId=76;\r\n\r\n    private int networkId = 7;\r\n\r\n    static public long blockHeight = 1;\r\n  \r\n    private Block parentBlock=null;\r\n    \r\n    private String exampleBlock = \"{\" +\r\n      \"\\\"difficulty\\\":\\\"0x5\\\",\" +\r\n      \"\\\"extraData\\\":\\\"0xd58301090083626f7286676f312e3133856c696e75780000000000000000000021c9effaf6549e725463c7877ddebe9a2916e03228624e4bfd1e3f811da792772b54d9e4eb793c54afb4a29f014846736755043e4778999046d0577c6e57e72100\\\",\"\r\n      + \"\\\"gasLimit\\\":\\\"0xe984c2\\\",\" + \"\\\"gasUsed\\\":\\\"0x0\\\",\" \r\n      + \"\\\"hash\\\":\\\"0xaa14340feb15e26bc354bb839b2aa41cc7984676249c155ac5e4d281a8d08809\\\",\"\r\n      + \"\\\"logsBloom\\\":\\\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\\",\"\r\n      + \"\\\"miner\\\":\\\"0x0000000000000000000000000000000000000000\\\",\" +\r\n      \"\\\"mixHash\\\":\\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\",\" +\r\n      \"\\\"nonce\\\":\\\"0x0000000000000000\\\",\" +\r\n      \"\\\"number\\\":\\\"0x1b4\\\",\" +\r\n      \"\\\"parentHash\\\":\\\"0xc8ccb81f484a428a3a1669d611f55f880b362b612f726711947d98f5bc5af573\\\",\" + \r\n      \"\\\"receiptsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" +\r\n      \"\\\"sha3Uncles\\\":\\\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\\\",\" +\r\n      \"\\\"size\\\":\\\"0x260\\\",\" +\r\n      \"\\\"stateRoot\\\":\\\"0xffcb834d62706995e9e7bf10cc9a9e42a82fea998d59b3a5cfad8975dbfe3f87\\\",\" +\r\n      \"\\\"timestamp\\\":\\\"0x5ed9a43f\\\",\" +\r\n      \"\\\"totalDifficulty\\\":\\\"0x881\\\",\" +\r\n      \"\\\"transactions\\\":[\" + \"],\" + \r\n      \"\\\"transactionsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" + \r\n      \"\\\"uncles\\\":[  \" + \"]}\";\r\n\r\n      \r\n\tprivate CustomFieldsCacheContainerProvider cetCache = getCDIBean(CustomFieldsCacheContainerProvider.class);\r\n    private CrossStorageService crossStorageService = getCDIBean(CrossStorageService.class);\r\n    private CustomTableService customTableService = getCDIBean(CustomTableService.class);\r\n    \r\n    private static PaginationConfiguration lastBlockPC = new PaginationConfiguration(\"blockNumber\",SortOrder.DESCENDING);\r\n  \r\n  \tprivate CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\r\n\r\n    \r\n    private static List<Transaction> currentTransactions = new ArrayList<>();\r\n    private static List<Transaction> nextTransactions = new ArrayList<>();\r\n  \r\n    private static Instant nextBlockDate;\r\n    private static AtomicBoolean isForging = new AtomicBoolean(false);\r\n  \r\n    public static void addTransaction(Transaction t){\r\n      if(isForging.get()){\r\n          nextTransactions.add(t);\r\n      } else {\r\n          currentTransactions.add(t);\r\n      }\r\n    }\r\n  \r\n    public Block getLastBlock(){\r\n        Block result = null;\r\n        try{\r\n            //log.info(\"query : \"+customTableService.getQuery(\"block\", lastBlockPC));\r\n        List<Map<String, Object>> res = crossStorageService.find(defaultRepo, cetCache.getCustomEntityTemplate(\"Block\"), lastBlockPC);\r\n        if(res.size()>0){\r\n            result = CEIUtils.deserialize(res.get(0), Block.class);\r\n            //log.info(\"lastBlock number:{}\",result.getBlockNumber());\r\n        }\r\n        } catch(Exception e){\r\n          log.error(\"getLastBlock:{}\",e);\r\n        }\r\n        return result;\r\n    }\r\n  \r\n    @Override\r\n    public void execute(Map<String, Object> parameters) throws BusinessException {\r\n      //log.info(\"execute forging\");\r\n      if(parentBlock==null){\r\n      \t//log.info(\"retreive last block from chain\");\r\n        parentBlock = getLastBlock();\r\n      }\r\n      if(isForging.getAndSet(true)){\r\n         log.error(\"we are already forging\");\r\n         return;\r\n      } \r\n      if(currentTransactions.size()==0){\r\n        //log.info(\"no transaction to forge\");\r\n        blockHeight=parentBlock.getBlockNumber();\r\n        isForging.set(false);\r\n        return;\r\n      } else {\r\n        log.info(\"forging {} transactions\",currentTransactions.size());\r\n        Map<String,Wallet> wallets = new HashMap<>();\r\n        List<Transaction> orderedTransactions = currentTransactions.stream().sorted((t1,t2)->(t1.getCreationDate().compareTo(t2.getCreationDate()))).collect(Collectors.toList());\r\n        \r\n        blockHeight=parentBlock.getBlockNumber()+1;\r\n        \r\n        String transactionHashes=\"\";\r\n        List<Transaction> invalidTransactions = new ArrayList<>();\r\n        for(Transaction t: currentTransactions){\r\n          log.info(\" transaction date : {}\",t.getCreationDate());\r\n          if(!wallets.containsKey(t.getFromHexHash())){\r\n            try{\r\n            \tWallet originWallet = crossStorageApi.find(defaultRepo,t.getFromHexHash(), Wallet.class);\r\n                log.info(\"add originWallet:{} {} to map\",originWallet.getUuid(),originWallet.getBalance());\r\n                wallets.put(t.getFromHexHash(),originWallet);\r\n            } catch(Exception e){\r\n              log.info(\" cannot find origin wallet, set blockNumber to INVALID\");\r\n              t.setBlockNumber(\"INVALID\");\r\n              try {\r\n              crossStorageApi.createOrUpdate(defaultRepo, t);\r\n              } catch(Exception ex){\r\n                ex.printStackTrace();\r\n              }\r\n              invalidTransactions.add(t);\r\n            }\r\n          }\r\n          if(t.getBlockNumber() == null){\r\n            Wallet originWallet = wallets.get(t.getFromHexHash());\r\n          \tlog.info(\"originWallet 0x{} old balance:{}\",t.getFromHexHash(),originWallet.getBalance());\r\n            BigInteger transacValue = new BigInteger(t.getValue());\r\n          \tif(new BigInteger(originWallet.getBalance()).compareTo(transacValue)>=0){\r\n                originWallet.setBalance(\"\"+new BigInteger(originWallet.getBalance()).add(transacValue.negate()));\r\n                try{\r\n            \t\tWallet destinationWallet = crossStorageApi.find(defaultRepo,t.getToHexHash(), Wallet.class);\r\n          \t\t\tlog.info(\"destinationWallet 0x{} old balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\r\n                    destinationWallet.setBalance(\"\"+new BigInteger(destinationWallet.getBalance()).add(transacValue));\r\n          \t\t\tcrossStorageApi.createOrUpdate(defaultRepo, destinationWallet);\r\n          \t\t\tlog.info(\"destinationWallet 0x{} new balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\r\n          \t\t\ttransactionHashes+=t.getHexHash();\r\n                } catch(Exception e){\r\n              \t\tlog.info(\" cannot find destination wallet, set blockNumber to INVALID\");\r\n              \t\tt.setBlockNumber(\"INVALID\");\r\n              \t\ttry{\r\n\t\t\t\t\t\tcrossStorageApi.createOrUpdate(defaultRepo, t);\r\n                    } catch(Exception ex){\r\n                \t\tex.printStackTrace();\r\n              \t\t}\r\n              \t\tinvalidTransactions.add(t);\r\n                }\r\n          \t} else {\r\n              log.info(\"insufficient balance, set blockNumber to INVALID\");\r\n              t.setBlockNumber(\"INVALID\");\r\n              try{\r\n              \tcrossStorageApi.createOrUpdate(defaultRepo, t);\r\n              } catch(Exception ex){\r\n                ex.printStackTrace();\r\n              }\r\n              invalidTransactions.add(t);\r\n            }\r\n          }\r\n        }\r\n        currentTransactions.removeAll(invalidTransactions);\r\n        Block block =  new Block();\r\n        block.setCreationDate(Instant.now());\r\n        \r\n        //FIXME parent should not be null\r\n        block.setParentHash(parentBlock==null?\"\":parentBlock.getHash());\r\n        block.setSize((long)currentTransactions.size());\r\n        \r\n        //FIXME hash parent hash\r\n        block.setHash(Hash.sha3(transactionHashes).substring(2));\r\n        \r\n        block.setBlockNumber(blockHeight);\r\n        try{\r\n          crossStorageApi.createOrUpdate(defaultRepo, block);\r\n          long i=0;\r\n          for(Transaction t: currentTransactions){\r\n              Wallet originWallet = wallets.get(t.getFromHexHash());\r\n              log.info(\"originWallet 0x{} new balance:{}\",t.getFromHexHash(),originWallet.getBalance());\r\n              crossStorageApi.createOrUpdate(defaultRepo, originWallet);\r\n              t.setBlockHash(block.getHash());\r\n              t.setBlockNumber(\"\"+block.getBlockNumber());\r\n              t.setTransactionIndex(i++);\r\n              crossStorageApi.createOrUpdate(defaultRepo, t);\r\n          }\r\n\r\n          parentBlock=block;\r\n          currentTransactions = nextTransactions;\r\n          nextTransactions = new ArrayList<>();\r\n        } catch(Exception ex){\r\n            ex.printStackTrace();\r\n        }\r\n        \r\n        isForging.set(false);\r\n      }\r\n    }\r\n  \r\n}\r\n",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ {
      "groupId" : "org.web3j",
      "artifactId" : "core",
      "version" : "4.8.9",
      "coordinates" : "org.web3j:core:4.8.9"
    } ],
    "importScriptInstances" : [ ]
  }, {
    "code" : "org.meveo.firebase.CloudMessaging",
    "description" : "Send notification and register users",
    "inputs" : [ {
      "name" : "userId",
      "type" : "String"
    }, {
      "name" : "title",
      "type" : "String"
    }, {
      "name" : "body",
      "type" : "String"
    } ],
    "outputs" : [ {
      "name" : "result",
      "type" : "String"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package org.meveo.firebase;\r\n\r\nimport java.util.Map;\r\nimport java.time.OffsetDateTime;\r\nimport java.time.Instant;\r\n\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException; \r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport javax.ws.rs.client.*;\r\nimport javax.ws.rs.core.*;\r\nimport com.google.gson.*;\r\n\r\nimport org.meveo.model.customEntities.Credential;\r\nimport org.meveo.model.customEntities.FCMToken;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.credentials.CredentialHelperService;\r\nimport org.meveo.model.persistence.CEIUtils;\r\nimport org.apache.commons.codec.digest.DigestUtils;\r\n\r\npublic class CloudMessaging extends Script {\r\n\r\n\tprivate static final Logger log = LoggerFactory.getLogger(CloudMessaging.class);\r\n\tprivate CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n\tprivate RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n\tprivate Repository defaultRepo = repositoryService.findDefaultRepository();\r\n\r\n\tstatic final private String FCM_DOMAIN = \"fcm.googleapis.com\";\r\n\r\n\tprivate String userId;\r\n\tprivate String title;\r\n\tprivate String body;\r\n\tprivate String result;\r\n\r\n\tpublic void setUserId(String userId){\r\n\t\tthis.userId = userId;\r\n\t}\r\n\r\n\tpublic void setTitle(String title){\r\n\t\tthis.title = title;\r\n\t}\r\n\t\r\n\tpublic void setBody(String body){\r\n\t\tthis.body = body;\r\n\t}\r\n  \r\n    public String getResult(){\r\n        return result;\r\n    }\r\n\r\n\t@Override\r\n\tpublic void execute(Map<String, Object> parameters) throws BusinessException {\r\n\t\tCredential credential = CredentialHelperService.getCredential(FCM_DOMAIN, crossStorageApi, defaultRepo);\r\n\t\tif (credential == null) {\r\n\t\t\tthrow new BusinessException(\"No credential found for \" + FCM_DOMAIN);\r\n\t\t} else {\r\n\t\t\tlog.info(\"using credential {} with username {}\", credential.getUuid(), credential.getUsername());\r\n\t\t}\r\n\t\tFCMToken token = null;\r\n\t\ttry{ \r\n\t\t\ttoken = crossStorageApi.find(defaultRepo,FCMToken.class).by(\"userId\",userId).getResult();\r\n\t\t} catch (Exception e){\r\n\t\t\tthrow new BusinessException(\"TOKEN_NOT_FOUND\");\r\n\t\t}\r\n\t\tClient client = ClientBuilder.newClient();\r\n\t\tclient.register(new CredentialHelperService.LoggingFilter());\r\n\t\tWebTarget target = client.target(\"https://fcm.googleapis.com/fcm/send\");\r\n      String notification = \"{\\n\"\r\n\t\t+\"\\\"title\\\": \\\"\"+title+\"\\\",\\n\"\r\n\t\t+\"\\\"body\\\": \\\"\"+body+\"\\\",\\n\"\r\n\t\t+\"}\";\r\n      String data =  \"{\"\r\n\t\t+\"\\\"userId\\\": \\\"\"+userId+\"\\\"\"\r\n\t\t+\"}\";\r\n\t\tString reqBody = \"{\\n\"\r\n\t\t+\"\\\"to\\\": \\\"\"+token.getToken()+\"\\\",\\n\"\r\n\t\t+\"\\\"title\\\": \\\"\"+title+\"\\\",\\n\"\r\n\t\t+\"\\\"body\\\": \\\"\"+body+\"\\\",\\n\"\r\n\t\t+\"\\\"notification\\\": \"+notification+\",\\n\"\r\n\t\t+\"\\\"data\\\": \"+data+\"\\n\"\r\n\t\t+\"}\";\r\n      log.info(\"out :{}\", reqBody);\r\n\t\tResponse response = CredentialHelperService.setCredential(target.request(), credential).post(Entity.json(reqBody));\r\n\t\tresult = response.readEntity(String.class);\r\n\t\tlog.info(\"response  :\" + result);\r\n\t}\r\n\r\n}",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ ],
    "importScriptInstances" : [ {
      "code" : "org.meveo.credentials.CredentialHelperService",
      "description" : "Helper function to build request with credentials",
      "inputs" : [ ],
      "outputs" : [ ],
      "generateOutputs" : false,
      "type" : "JAVA",
      "transactionType" : "SAME",
      "script" : "package org.meveo.credentials;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport javax.ws.rs.client.*;\r\n\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport org.meveo.model.customEntities.Credential;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.elresolver.ValueExpressionWrapper;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\npublic class CredentialHelperService extends Script {\r\n  \r\n  private static final Logger log = LoggerFactory.getLogger(CredentialHelperService.class);\r\n\r\n    public static class LoggingFilter implements ClientRequestFilter {\r\n        @Override\r\n        public void filter(ClientRequestContext requestContext) throws IOException {\r\n            if(requestContext!=null){\r\n              if(requestContext.getEntity()!=null){\r\n                log.info(requestContext.getEntity().toString());\r\n              } else {\r\n                log.info(\"uri:{}\",requestContext.getUri());\r\n              }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static Credential getCredential(String domain,CrossStorageApi crossStorageApiInstance,Repository repo){\r\n      List<Credential> matchigCredentials = crossStorageApiInstance.find(repo, Credential.class)\r\n                .by(\"domainName\", domain)\r\n\t\t\t\t.getResults();\r\n      if(matchigCredentials.size()>0){\r\n        return matchigCredentials.get(0);\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n  \r\n    public static Invocation.Builder setCredential(Invocation.Builder invocBuilder,Credential credential) throws BusinessException {\r\n      String headerKey = credential.getHeaderKey();\r\n      String headerValue = credential.getHeaderValue();\r\n      try{\r\n        if(headerKey.contains(\"#{\")){\r\n          headerKey=ValueExpressionWrapper.evaluateToStringMultiVariable(headerKey,\"entity\",credential);\r\n        }\r\n        if(headerValue.contains(\"#{\")){\r\n          headerValue=ValueExpressionWrapper.evaluateToStringMultiVariable(headerValue,\"entity\",credential);\r\n        }\r\n      } catch(Exception e) {\r\n        throw new BusinessException(e);\r\n      }\r\n      return invocBuilder.header(headerKey, headerValue);\r\n    }\r\n  \r\n\t@Override\r\n\tpublic void execute(Map<String, Object> parameters) throws BusinessException {\r\n    }\r\n\t\r\n}",
      "executionRoles" : [ ],
      "sourcingRoles" : [ ],
      "mavenDependencies" : [ ],
      "importScriptInstances" : [ ]
    } ]
  } ]
}