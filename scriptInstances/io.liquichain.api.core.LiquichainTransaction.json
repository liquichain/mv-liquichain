{
  "code" : "io.liquichain.api.core.LiquichainTransaction",
  "description" : "perform transaction from internal accounts",
  "inputs" : [ {
    "name" : "fromAddress",
    "type" : "String"
  }, {
    "name" : "toAddress",
    "type" : "String"
  }, {
    "name" : "value",
    "type" : "String"
  } ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.core;\r\n\r\nimport java.math.BigInteger;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Optional;\r\n\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.commons.utils.ParamBean;\r\nimport org.meveo.commons.utils.ParamBeanFactory;\r\nimport org.meveo.model.customEntities.Transaction;\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.persistence.CrossStorageService;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.web3j.crypto.Credentials;\r\nimport org.web3j.crypto.Hash;\r\nimport org.web3j.crypto.RawTransaction;\r\nimport org.web3j.crypto.TransactionEncoder;\r\nimport org.web3j.protocol.Web3j;\r\nimport org.web3j.protocol.core.DefaultBlockParameterName;\r\nimport org.web3j.protocol.core.methods.response.EthGetTransactionCount;\r\nimport org.web3j.protocol.core.methods.response.EthGetTransactionReceipt;\r\nimport org.web3j.protocol.core.methods.response.EthSendTransaction;\r\nimport org.web3j.protocol.core.methods.response.TransactionReceipt;\r\nimport org.web3j.protocol.http.HttpService;\r\nimport org.web3j.utils.Convert;\r\nimport org.web3j.utils.Convert.Unit;\r\nimport org.web3j.utils.Numeric;\r\n\r\nimport io.liquichain.core.BlockForgerScript;\r\n//import org.meveo.firebase.CloudMessaging;\r\n\r\npublic class LiquichainTransaction extends Script {\r\n    private static final Logger log = LoggerFactory.getLogger(LiquichainTransaction.class);\r\n    private static final long LIQUICHAIN_CHAINID = 76l;\r\n    private static final int SLEEP_DURATION = 15000;\r\n    private static final int ATTEMPTS = 40;\r\n\r\n    private CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\r\n    private ParamBeanFactory paramBeanFactory = getCDIBean(ParamBeanFactory.class);\r\n    private ParamBean config = paramBeanFactory.getInstance();\r\n    private String besuApiUrl = config.getProperty(\"besu.api.url\", \"http://51.159.10.146/rpc\");\r\n    private Web3j web3j = Web3j.build(new HttpService(besuApiUrl));\r\n    //private CloudMessaging cloudMessaging = new CloudMessaging();\r\n\r\n    private static enum BLOCKCHAIN_TYPE {\r\n        DATABASE, BESU, FABRIC\r\n    }\r\n\r\n    private static final BLOCKCHAIN_TYPE BLOCKCHAIN_BACKEND = BLOCKCHAIN_TYPE.DATABASE;\r\n\r\n\r\n    private String fromAddress;\r\n    private String toAddress;\r\n    private String value;\r\n    private String result;\r\n\r\n    public void setFromAddress(String fromAddress) {\r\n        this.fromAddress = fromAddress;\r\n    }\r\n\r\n    public void setToAddress(String toAddress) {\r\n        this.toAddress = toAddress;\r\n    }\r\n\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n\r\n    public String getResult() {\r\n        return result;\r\n    }\r\n\r\n    public String transferDB(String fromAddress, String toAddress, BigInteger value)\r\n            throws Exception {\r\n        String transactionHash = \"\";\r\n        Wallet toWallet = crossStorageApi.find(defaultRepo, toAddress, Wallet.class);\r\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, fromAddress, Wallet.class);\r\n        if (fromWallet.getPrivateKey() == null) {\r\n            throw new Exception(\"wallet has no private key\");\r\n        }\r\n        String privateKey = fromWallet.getPrivateKey();\r\n        if (privateKey.startsWith(\"0x\")) {\r\n            privateKey = privateKey.substring(2);\r\n        }\r\n        BigInteger originBalance = new BigInteger(fromWallet.getBalance());\r\n        log.info(\"originWallet 0x{} old balance:{} amount:{}\", fromAddress, fromWallet.getBalance(),\r\n                value);\r\n        if (value.compareTo(originBalance) > 0) {\r\n            throw new BusinessException(\"Insufficient balance\");\r\n        }\r\n\r\n        List<Transaction> walletTransactions = crossStorageApi.find(defaultRepo, Transaction.class)\r\n                .by(\"fromHexHash\", fromWallet.getUuid()).getResults();\r\n        BigInteger nonce = BigInteger.ONE;\r\n        if (walletTransactions != null && walletTransactions.size() > 0) {\r\n            walletTransactions.sort(Comparator.comparing(Transaction::getNonce).reversed());\r\n            Transaction lastTransaction = walletTransactions.get(0);\r\n            try {\r\n                nonce = BigInteger.valueOf(Long.parseLong(lastTransaction.getNonce()) + 1);\r\n            } catch (Exception e) {\r\n                log.error(\"invalid nonce :{}\", lastTransaction.getNonce());\r\n            }\r\n        }\r\n        String recipientAddress = \"0x\" + toWallet.getUuid();\r\n        BigInteger gasLimit = BigInteger.ZERO;\r\n        BigInteger gasPrice = BigInteger.ZERO;\r\n        RawTransaction rawTransaction = RawTransaction.createEtherTransaction(nonce, gasPrice,\r\n                gasLimit, recipientAddress, value);\r\n        Credentials credentials = Credentials.create(privateKey);\r\n        byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\r\n        String hexValue = Numeric.toHexString(signedMessage);\r\n\r\n        Transaction transac = new Transaction();\r\n        transactionHash = Hash.sha3(hexValue);\r\n        transac.setHexHash(transactionHash.substring(2));\r\n        transac.setFromHexHash(fromWallet.getUuid());\r\n        transac.setToHexHash(toWallet.getUuid());\r\n        transac.setNonce(\"\" + nonce);\r\n        transac.setGasPrice(\"0\");\r\n        transac.setGasLimit(\"0\");\r\n        transac.setValue(\"\" + value);\r\n\r\n        transac.setSignedHash(hexValue.substring(2));\r\n\r\n        transac.setCreationDate(java.time.Instant.now());\r\n\r\n        crossStorageApi.createOrUpdate(defaultRepo, transac);\r\n        // FIXME: you should get the BlockForgerScript from scriptService\r\n\r\n        BlockForgerScript.addTransaction(transac);\r\n        return transactionHash;\r\n    }\r\n\r\n    /*private Optional<TransactionReceipt> sendTransactionReceiptRequest(String transactionHash)\r\n            throws Exception {\r\n        EthGetTransactionReceipt transactionReceipt = web3j\r\n                .ethGetTransactionReceipt(transactionHash)\r\n                .sendAsync()\r\n                .get();\r\n\r\n        return transactionReceipt.getTransactionReceipt();\r\n    }\r\n\r\n    private Optional<TransactionReceipt> getTransactionReceipt(String transactionHash,\r\n            int sleepDuration, int attempts) throws Exception {\r\n        Optional<TransactionReceipt> receiptOptional =\r\n                sendTransactionReceiptRequest(transactionHash);\r\n        for (int i = 0; i < attempts; i++) {\r\n            if (!receiptOptional.isPresent()) {\r\n                Thread.sleep(sleepDuration);\r\n                receiptOptional = sendTransactionReceiptRequest(transactionHash);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return receiptOptional;\r\n    }\r\n\r\n    private TransactionReceipt waitForTransactionReceipt(String transactionHash) throws Exception {\r\n        Optional<TransactionReceipt> transactionReceiptOptional =\r\n                getTransactionReceipt(transactionHash, SLEEP_DURATION, ATTEMPTS);\r\n\r\n        if (!transactionReceiptOptional.isPresent()) {\r\n            throw new BusinessException(\r\n                    \"Transaction receipt not generated after \" + ATTEMPTS + \" attempts\");\r\n        }\r\n        return transactionReceiptOptional.get();\r\n    }\r\n\r\n    private String transferBesu(String fromAddress, String toAddress, BigInteger amount)\r\n            throws Exception {\r\n        Wallet toWallet = crossStorageApi.find(defaultRepo, toAddress, Wallet.class);\r\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, fromAddress, Wallet.class);\r\n        String privateKey = fromWallet.getPrivateKey();\r\n\r\n        Credentials credentials = Credentials.create(privateKey);\r\n        EthGetTransactionCount ethGetTransactionCount = web3j\r\n                .ethGetTransactionCount(credentials.getAddress(), DefaultBlockParameterName.LATEST)\r\n                .send();\r\n        BigInteger nonce = ethGetTransactionCount.getTransactionCount();\r\n\r\n        BigInteger gasLimit = BigInteger.valueOf(21000);\r\n        BigInteger gasPrice = Convert.toWei(\"1\", Unit.GWEI).toBigInteger();\r\n\r\n        RawTransaction rawTransaction = RawTransaction\r\n                .createEtherTransaction(nonce, gasPrice, gasLimit, toAddress, amount);\r\n\r\n        byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\r\n        String hexValue = Numeric.toHexString(signedMessage);\r\n\r\n        EthSendTransaction ethSendTransaction = web3j\r\n                .ethSendRawTransaction(hexValue)\r\n                .sendAsync()\r\n                .get();\r\n\r\n        String transactionHash = ethSendTransaction.getTransactionHash();\r\n\r\n        TransactionReceipt transactionReceipt = waitForTransactionReceipt(transactionHash);\r\n\r\n        return transactionReceipt.getTransactionHash();\r\n    }*/\r\n\r\n    private String transferFabric(String fromAddress, String toAddress, BigInteger amount)\r\n            throws Exception {\r\n        return \"\";\r\n    }\r\n\r\n    public String transfer(String fromAddress, String toAddress, BigInteger amount) throws Exception {\r\n        return transfer(fromAddress,toAddress,amount,\"You received coins !\");\r\n    }\r\n\r\n    public String transfer(String fromAddress, String toAddress, BigInteger amount,String message)\r\n            throws Exception {\r\n        String transactionHash = \"\";\r\n        switch (BLOCKCHAIN_BACKEND) {\r\n            case BESU:\r\n                //transactionHash = transferBesu(fromAddress, toAddress, amount);\r\n                break;\r\n            case FABRIC:\r\n                transactionHash = transferFabric(fromAddress, toAddress, amount);\r\n                break;\r\n            default:\r\n                transactionHash = transferDB(fromAddress, toAddress, amount);\r\n                break;\r\n        }\r\n        try{\r\n            if(!transactionHash.isEmpty()){\r\n                //cloudMessaging.setUserId(toAddress);\r\n                //cloudMessaging.setTitle(\"telecel play\");\r\n                //cloudMessaging.setBody(message);\r\n                //cloudMessaging.execute(null);\r\n            }\r\n        } catch(Exception e){\r\n            log.warn(\"cannot send notification to {}:{}\",toAddress,message);\r\n        }\r\n        return transactionHash;\r\n    }\r\n\r\n    // used to transfer from local account\r\n    @Override\r\n    public void execute(Map<String, Object> parameters) throws BusinessException {\r\n        String transactionHash = \"\";\r\n        try {\r\n            transactionHash = transfer(fromAddress, toAddress, new BigInteger(value));\r\n            result = \"{\\\"transaction_hash\\\":\\\"\" + transactionHash + \"\\\"}\";\r\n        } catch (Exception e) {\r\n            log.error(\" transafer error\", e);\r\n            result = \"{\\\"error\\\":\\\"\" + e.getMessage() + \"\\\"}\";\r\n        }\r\n    }\r\n\r\n}\r\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ ],
  "importScriptInstances" : [ {
    "code" : "io.liquichain.core.BlockForgerScript",
    "description" : "Bock forging script",
    "inputs" : [ ],
    "outputs" : [ {
      "name" : "lastBlock",
      "type" : "Block"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package io.liquichain.core;\r\n\r\nimport java.util.Map;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Arrays;\r\nimport java.util.ArrayList;\r\nimport java.math.BigInteger;\r\nimport java.time.Instant;\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\nimport java.util.stream.Collectors;\r\nimport java.io.IOException;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.math.BigInteger;\r\nimport org.meveo.model.customEntities.Block;\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.customEntities.Transaction;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.persistence.CrossStorageService;\r\nimport org.meveo.cache.CustomFieldsCacheContainerProvider;\r\nimport org.meveo.api.exception.EntityDoesNotExistsException;\r\nimport org.meveo.admin.util.pagination.PaginationConfiguration;\r\nimport org.meveo.model.persistence.CEIUtils;\r\nimport org.meveo.service.custom.CustomTableService;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.primefaces.model.SortOrder;\r\n\r\nimport org.web3j.crypto.*;\r\n\r\npublic class BlockForgerScript extends Script {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(BlockForgerScript.class);\r\n  \r\n    private static long chainId=76;\r\n\r\n    private int networkId = 7;\r\n\r\n    static public long blockHeight = 1;\r\n  \r\n    private Block parentBlock=null;\r\n    \r\n    private String exampleBlock = \"{\" +\r\n      \"\\\"difficulty\\\":\\\"0x5\\\",\" +\r\n      \"\\\"extraData\\\":\\\"0xd58301090083626f7286676f312e3133856c696e75780000000000000000000021c9effaf6549e725463c7877ddebe9a2916e03228624e4bfd1e3f811da792772b54d9e4eb793c54afb4a29f014846736755043e4778999046d0577c6e57e72100\\\",\"\r\n      + \"\\\"gasLimit\\\":\\\"0xe984c2\\\",\" + \"\\\"gasUsed\\\":\\\"0x0\\\",\" \r\n      + \"\\\"hash\\\":\\\"0xaa14340feb15e26bc354bb839b2aa41cc7984676249c155ac5e4d281a8d08809\\\",\"\r\n      + \"\\\"logsBloom\\\":\\\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\\",\"\r\n      + \"\\\"miner\\\":\\\"0x0000000000000000000000000000000000000000\\\",\" +\r\n      \"\\\"mixHash\\\":\\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\",\" +\r\n      \"\\\"nonce\\\":\\\"0x0000000000000000\\\",\" +\r\n      \"\\\"number\\\":\\\"0x1b4\\\",\" +\r\n      \"\\\"parentHash\\\":\\\"0xc8ccb81f484a428a3a1669d611f55f880b362b612f726711947d98f5bc5af573\\\",\" + \r\n      \"\\\"receiptsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" +\r\n      \"\\\"sha3Uncles\\\":\\\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\\\",\" +\r\n      \"\\\"size\\\":\\\"0x260\\\",\" +\r\n      \"\\\"stateRoot\\\":\\\"0xffcb834d62706995e9e7bf10cc9a9e42a82fea998d59b3a5cfad8975dbfe3f87\\\",\" +\r\n      \"\\\"timestamp\\\":\\\"0x5ed9a43f\\\",\" +\r\n      \"\\\"totalDifficulty\\\":\\\"0x881\\\",\" +\r\n      \"\\\"transactions\\\":[\" + \"],\" + \r\n      \"\\\"transactionsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" + \r\n      \"\\\"uncles\\\":[  \" + \"]}\";\r\n\r\n      \r\n\tprivate CustomFieldsCacheContainerProvider cetCache = getCDIBean(CustomFieldsCacheContainerProvider.class);\r\n    private CrossStorageService crossStorageService = getCDIBean(CrossStorageService.class);\r\n    private CustomTableService customTableService = getCDIBean(CustomTableService.class);\r\n    \r\n    private static PaginationConfiguration lastBlockPC = new PaginationConfiguration(\"blockNumber\",SortOrder.DESCENDING);\r\n  \r\n  \tprivate CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\r\n\r\n    \r\n    private static List<Transaction> currentTransactions = new ArrayList<>();\r\n    private static List<Transaction> nextTransactions = new ArrayList<>();\r\n  \r\n    private static Instant nextBlockDate;\r\n    private static AtomicBoolean isForging = new AtomicBoolean(false);\r\n  \r\n    public static void addTransaction(Transaction t){\r\n      if(isForging.get()){\r\n          nextTransactions.add(t);\r\n      } else {\r\n          currentTransactions.add(t);\r\n      }\r\n    }\r\n  \r\n    public Block getLastBlock(){\r\n        Block result = null;\r\n        try{\r\n            //log.info(\"query : \"+customTableService.getQuery(\"block\", lastBlockPC));\r\n        List<Map<String, Object>> res = crossStorageService.find(defaultRepo, cetCache.getCustomEntityTemplate(\"Block\"), lastBlockPC);\r\n        if(res.size()>0){\r\n            result = CEIUtils.deserialize(res.get(0), Block.class);\r\n            //log.info(\"lastBlock number:{}\",result.getBlockNumber());\r\n        }\r\n        } catch(Exception e){\r\n          log.error(\"getLastBlock:{}\",e);\r\n        }\r\n        return result;\r\n    }\r\n  \r\n    @Override\r\n    public void execute(Map<String, Object> parameters) throws BusinessException {\r\n      //log.info(\"execute forging\");\r\n      if(parentBlock==null){\r\n      \t//log.info(\"retreive last block from chain\");\r\n        parentBlock = getLastBlock();\r\n      }\r\n      if(isForging.getAndSet(true)){\r\n         log.error(\"we are already forging\");\r\n         return;\r\n      } \r\n      if(currentTransactions.size()==0){\r\n        //log.info(\"no transaction to forge\");\r\n        blockHeight=parentBlock.getBlockNumber();\r\n        isForging.set(false);\r\n        return;\r\n      } else {\r\n        log.info(\"forging {} transactions\",currentTransactions.size());\r\n        Map<String,Wallet> wallets = new HashMap<>();\r\n        List<Transaction> orderedTransactions = currentTransactions.stream().sorted((t1,t2)->(t1.getCreationDate().compareTo(t2.getCreationDate()))).collect(Collectors.toList());\r\n        \r\n        blockHeight=parentBlock.getBlockNumber()+1;\r\n        \r\n        String transactionHashes=\"\";\r\n        List<Transaction> invalidTransactions = new ArrayList<>();\r\n        for(Transaction t: currentTransactions){\r\n          log.info(\" transaction date : {}\",t.getCreationDate());\r\n          if(!wallets.containsKey(t.getFromHexHash())){\r\n            try{\r\n            \tWallet originWallet = crossStorageApi.find(defaultRepo,t.getFromHexHash(), Wallet.class);\r\n                log.info(\"add originWallet:{} {} to map\",originWallet.getUuid(),originWallet.getBalance());\r\n                wallets.put(t.getFromHexHash(),originWallet);\r\n            } catch(Exception e){\r\n              log.info(\" cannot find origin wallet, set blockNumber to INVALID\");\r\n              t.setBlockNumber(\"INVALID\");\r\n              try {\r\n              crossStorageApi.createOrUpdate(defaultRepo, t);\r\n              } catch(Exception ex){\r\n                ex.printStackTrace();\r\n              }\r\n              invalidTransactions.add(t);\r\n            }\r\n          }\r\n          if(t.getBlockNumber() == null){\r\n            Wallet originWallet = wallets.get(t.getFromHexHash());\r\n          \tlog.info(\"originWallet 0x{} old balance:{}\",t.getFromHexHash(),originWallet.getBalance());\r\n            BigInteger transacValue = new BigInteger(t.getValue());\r\n          \tif(new BigInteger(originWallet.getBalance()).compareTo(transacValue)>=0){\r\n                originWallet.setBalance(\"\"+new BigInteger(originWallet.getBalance()).add(transacValue.negate()));\r\n                try{\r\n            \t\tWallet destinationWallet = crossStorageApi.find(defaultRepo,t.getToHexHash(), Wallet.class);\r\n          \t\t\tlog.info(\"destinationWallet 0x{} old balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\r\n                    destinationWallet.setBalance(\"\"+new BigInteger(destinationWallet.getBalance()).add(transacValue));\r\n          \t\t\tcrossStorageApi.createOrUpdate(defaultRepo, destinationWallet);\r\n          \t\t\tlog.info(\"destinationWallet 0x{} new balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\r\n          \t\t\ttransactionHashes+=t.getHexHash();\r\n                } catch(Exception e){\r\n              \t\tlog.info(\" cannot find destination wallet, set blockNumber to INVALID\");\r\n              \t\tt.setBlockNumber(\"INVALID\");\r\n              \t\ttry{\r\n\t\t\t\t\t\tcrossStorageApi.createOrUpdate(defaultRepo, t);\r\n                    } catch(Exception ex){\r\n                \t\tex.printStackTrace();\r\n              \t\t}\r\n              \t\tinvalidTransactions.add(t);\r\n                }\r\n          \t} else {\r\n              log.info(\"insufficient balance, set blockNumber to INVALID\");\r\n              t.setBlockNumber(\"INVALID\");\r\n              try{\r\n              \tcrossStorageApi.createOrUpdate(defaultRepo, t);\r\n              } catch(Exception ex){\r\n                ex.printStackTrace();\r\n              }\r\n              invalidTransactions.add(t);\r\n            }\r\n          }\r\n        }\r\n        currentTransactions.removeAll(invalidTransactions);\r\n        Block block =  new Block();\r\n        block.setCreationDate(Instant.now());\r\n        \r\n        //FIXME parent should not be null\r\n        block.setParentHash(parentBlock==null?\"\":parentBlock.getHash());\r\n        block.setSize((long)currentTransactions.size());\r\n        \r\n        //FIXME hash parent hash\r\n        block.setHash(Hash.sha3(transactionHashes).substring(2));\r\n        \r\n        block.setBlockNumber(blockHeight);\r\n        try{\r\n          crossStorageApi.createOrUpdate(defaultRepo, block);\r\n          long i=0;\r\n          for(Transaction t: currentTransactions){\r\n              Wallet originWallet = wallets.get(t.getFromHexHash());\r\n              log.info(\"originWallet 0x{} new balance:{}\",t.getFromHexHash(),originWallet.getBalance());\r\n              crossStorageApi.createOrUpdate(defaultRepo, originWallet);\r\n              t.setBlockHash(block.getHash());\r\n              t.setBlockNumber(\"\"+block.getBlockNumber());\r\n              t.setTransactionIndex(i++);\r\n              crossStorageApi.createOrUpdate(defaultRepo, t);\r\n          }\r\n\r\n          parentBlock=block;\r\n          currentTransactions = nextTransactions;\r\n          nextTransactions = new ArrayList<>();\r\n        } catch(Exception ex){\r\n            ex.printStackTrace();\r\n        }\r\n        \r\n        isForging.set(false);\r\n      }\r\n    }\r\n  \r\n}\r\n",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ {
      "groupId" : "org.web3j",
      "artifactId" : "crypto",
      "version" : "4.8.9",
      "coordinates" : "org.web3j:crypto:4.8.9"
    } ],
    "importScriptInstances" : [ ]
  }, {
    "code" : "org.meveo.firebase.CloudMessaging",
    "description" : "Send notification and register users",
    "inputs" : [ {
      "name" : "userId",
      "type" : "String"
    }, {
      "name" : "title",
      "type" : "String"
    }, {
      "name" : "body",
      "type" : "String"
    } ],
    "outputs" : [ {
      "name" : "result",
      "type" : "String"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package org.meveo.firebase;\r\n\r\nimport java.util.Map;\r\nimport java.time.OffsetDateTime;\r\nimport java.time.Instant;\r\n\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException; \r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport javax.ws.rs.client.*;\r\nimport javax.ws.rs.core.*;\r\nimport com.google.gson.*;\r\n\r\nimport org.meveo.model.customEntities.Credential;\r\nimport org.meveo.model.customEntities.FCMToken;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.credentials.CredentialHelperService;\r\nimport org.meveo.model.persistence.CEIUtils;\r\nimport org.apache.commons.codec.digest.DigestUtils;\r\n\r\npublic class CloudMessaging extends Script {\r\n\r\n\tprivate static final Logger log = LoggerFactory.getLogger(CloudMessaging.class);\r\n\tprivate CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n\tprivate RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n\tprivate Repository defaultRepo = repositoryService.findDefaultRepository();\r\n\r\n\tstatic final private String FCM_DOMAIN = \"fcm.googleapis.com\";\r\n\r\n\tprivate String userId;\r\n\tprivate String title;\r\n\tprivate String body;\r\n\tprivate String result;\r\n\r\n\tpublic void setUserId(String userId){\r\n\t\tthis.userId = userId;\r\n\t}\r\n\r\n\tpublic void setTitle(String title){\r\n\t\tthis.title = title;\r\n\t}\r\n\t\r\n\tpublic void setBody(String body){\r\n\t\tthis.body = body;\r\n\t}\r\n  \r\n    public String getResult(){\r\n        return result;\r\n    }\r\n\r\n\t@Override\r\n\tpublic void execute(Map<String, Object> parameters) throws BusinessException {\r\n\t\tCredential credential = CredentialHelperService.getCredential(FCM_DOMAIN, crossStorageApi, defaultRepo);\r\n\t\tif (credential == null) {\r\n\t\t\tthrow new BusinessException(\"No credential found for \" + FCM_DOMAIN);\r\n\t\t} else {\r\n\t\t\tlog.info(\"using credential {} with username {}\", credential.getUuid(), credential.getUsername());\r\n\t\t}\r\n\t\tFCMToken token = null;\r\n\t\ttry{ \r\n\t\t\ttoken = crossStorageApi.find(defaultRepo,FCMToken.class).by(\"userId\",userId).getResult();\r\n\t\t} catch (Exception e){\r\n\t\t\tthrow new BusinessException(\"TOKEN_NOT_FOUND\");\r\n\t\t}\r\n\t\tClient client = ClientBuilder.newClient();\r\n\t\tclient.register(new CredentialHelperService.LoggingFilter());\r\n\t\tWebTarget target = client.target(\"https://fcm.googleapis.com/fcm/send\");\r\n      String notification = \"{\\n\"\r\n\t\t+\"\\\"title\\\": \\\"\"+title+\"\\\",\\n\"\r\n\t\t+\"\\\"body\\\": \\\"\"+body+\"\\\",\\n\"\r\n\t\t+\"}\";\r\n      String data =  \"{\"\r\n\t\t+\"\\\"userId\\\": \\\"\"+userId+\"\\\"\"\r\n\t\t+\"}\";\r\n\t\tString reqBody = \"{\\n\"\r\n\t\t+\"\\\"to\\\": \\\"\"+token.getToken()+\"\\\",\\n\"\r\n\t\t+\"\\\"title\\\": \\\"\"+title+\"\\\",\\n\"\r\n\t\t+\"\\\"body\\\": \\\"\"+body+\"\\\",\\n\"\r\n\t\t+\"\\\"notification\\\": \"+notification+\",\\n\"\r\n\t\t+\"\\\"data\\\": \"+data+\"\\n\"\r\n\t\t+\"}\";\r\n      log.info(\"out :{}\", reqBody);\r\n\t\tResponse response = CredentialHelperService.setCredential(target.request(), credential).post(Entity.json(reqBody));\r\n\t\tresult = response.readEntity(String.class);\r\n\t\tlog.info(\"response  :\" + result);\r\n\t}\r\n\r\n}",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ ],
    "importScriptInstances" : [ {
      "code" : "org.meveo.credentials.CredentialHelperService",
      "description" : "Helper function to build request with credentials",
      "inputs" : [ ],
      "outputs" : [ ],
      "generateOutputs" : false,
      "type" : "JAVA",
      "transactionType" : "SAME",
      "script" : "package org.meveo.credentials;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport javax.ws.rs.client.*;\r\n\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport org.meveo.model.customEntities.Credential;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.elresolver.ValueExpressionWrapper;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport javax.xml.bind.DatatypeConverter;\r\n\r\n\r\npublic class CredentialHelperService extends Script {\r\n  \r\n  private static final Logger log = LoggerFactory.getLogger(CredentialHelperService.class);\r\n\r\n    public static class LoggingFilter implements ClientRequestFilter {\r\n        @Override\r\n        public void filter(ClientRequestContext requestContext) throws IOException {\r\n            if(requestContext!=null){\r\n              if(requestContext.getEntity()!=null){\r\n                log.info(requestContext.getEntity().toString());\r\n              } else {\r\n                log.info(\"uri:{}\",requestContext.getUri());\r\n              }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static Credential getCredential(String domain,CrossStorageApi crossStorageApiInstance,Repository repo){\r\n      List<Credential> matchigCredentials = crossStorageApiInstance.find(repo, Credential.class)\r\n                .by(\"domainName\", domain)\r\n\t\t\t\t.getResults();\r\n      if(matchigCredentials.size()>0){\r\n        return matchigCredentials.get(0);\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n  \r\n    public static Invocation.Builder setCredential(Invocation.Builder invocBuilder,Credential credential) throws BusinessException {\r\n      Invocation.Builder result=invocBuilder;\r\n      if(\"BASIC_HTTP\".equals(credential.getAuthenticationType())){\r\n        try{\r\n          String token = credential.getUsername() + \":\" + credential.getPassword();\r\n          String headerValue = \"BASIC \" + DatatypeConverter.printBase64Binary(token.getBytes(\"UTF-8\"));\r\n          result=invocBuilder.header(\"Authorization\", headerValue);} \r\n        catch (Exception ex) {\r\n            throw new BusinessException(\"Cannot encode with UTF-8\", ex);\r\n        }\r\n      } else if(\"HEADER\".equals(credential.getAuthenticationType())){\r\n        String headerKey = credential.getHeaderKey();\r\n        String headerValue = credential.getHeaderValue();\r\n        try{\r\n          if(headerKey.contains(\"#{\")){\r\n            headerKey=ValueExpressionWrapper.evaluateToStringMultiVariable(headerKey,\"entity\",credential);\r\n          }\r\n          if(headerValue.contains(\"#{\")){\r\n            headerValue=ValueExpressionWrapper.evaluateToStringMultiVariable(headerValue,\"entity\",credential);\r\n          }\r\n          result=invocBuilder.header(headerKey, headerValue);\r\n        } catch(Exception e) {\r\n          throw new BusinessException(e);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n  \r\n\t@Override\r\n\tpublic void execute(Map<String, Object> parameters) throws BusinessException {\r\n    }\r\n\t\r\n}",
      "executionRoles" : [ ],
      "sourcingRoles" : [ ],
      "mavenDependencies" : [ ],
      "importScriptInstances" : [ ]
    } ]
  } ]
}