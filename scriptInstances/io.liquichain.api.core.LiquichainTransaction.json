{
  "code" : "io.liquichain.api.core.LiquichainTransaction",
  "description" : "perform transaction from internal accounts",
  "inputs" : [ {
    "name" : "fromAddress",
    "type" : "String"
  }, {
    "name" : "toAddress",
    "type" : "String"
  }, {
    "name" : "value",
    "type" : "String"
  } ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.core;\r\n\r\nimport static org.web3j.protocol.core.DefaultBlockParameterName.LATEST;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.math.BigInteger;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Optional;\r\n\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.commons.utils.ParamBean;\r\nimport org.meveo.commons.utils.ParamBeanFactory;\r\nimport org.meveo.model.customEntities.Transaction;\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.service.storage.RepositoryService;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport javax.ws.rs.client.*;\r\nimport javax.ws.rs.core.*;\r\n\r\nimport org.web3j.abi.datatypes.Address;\r\nimport org.web3j.abi.datatypes.Bool;\r\nimport org.web3j.abi.datatypes.Function;\r\nimport org.web3j.abi.datatypes.generated.Uint256;\r\nimport org.web3j.abi.FunctionEncoder;\r\nimport org.web3j.abi.TypeReference;\r\nimport org.web3j.crypto.Credentials;\r\nimport org.web3j.crypto.Hash;\r\nimport org.web3j.crypto.RawTransaction;\r\nimport org.web3j.crypto.TransactionEncoder;\r\nimport org.web3j.protocol.Web3j;\r\nimport org.web3j.protocol.core.methods.response.EthGetBalance;\r\nimport org.web3j.protocol.core.methods.response.EthGetTransactionCount;\r\nimport org.web3j.protocol.core.methods.response.EthGetTransactionReceipt;\r\nimport org.web3j.protocol.core.methods.response.EthSendTransaction;\r\nimport org.web3j.protocol.core.methods.response.TransactionReceipt;\r\nimport org.web3j.protocol.exceptions.ClientConnectionException;\r\nimport org.web3j.protocol.Service;\r\nimport org.web3j.tx.RawTransactionManager;\r\nimport org.web3j.utils.Convert;\r\nimport org.web3j.utils.Convert.Unit;\r\nimport org.web3j.utils.Numeric;\r\n\r\nimport org.meveo.firebase.CloudMessaging;\r\nimport io.liquichain.core.BlockForgerScript;\r\n\r\npublic class LiquichainTransaction extends Script {\r\n    private static final Logger LOG = LoggerFactory.getLogger(LiquichainTransaction.class);\r\n    private static final int SLEEP_DURATION = 15000;\r\n    private static final int ATTEMPTS = 40;\r\n    private static final String INSUFFICIENT_BALANCE = \"Insufficient balance\";\r\n    private static final String TRANSACTION_FAILED = \"Transaction failed\";\r\n    private static final String TRANSACTION_DATA_FORMAT = \"{\\\"type\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\"}\";\r\n\r\n    private CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\r\n    private ParamBeanFactory paramBeanFactory = getCDIBean(ParamBeanFactory.class);\r\n    private ParamBean config = paramBeanFactory.getInstance();\r\n    private String besuApiUrl = config\r\n            .getProperty(\"besu.api.url\", \"https://testnet.liquichain.io/rpc\");\r\n    private BigInteger defaultGasLimit =\r\n            new BigInteger(config.getProperty(\"besu.gas.limit\", \"120000\"));\r\n    private BigInteger defaultGasPrice = new BigInteger(config.getProperty(\"besu.gas.price\", \"0\"));\r\n    private String smartContract = config\r\n            .getProperty(\"besu.smart.contract\", \"0x0Cd07348D582a6F4A3641D3192f1f467586BE990\");\r\n\r\n    private Web3j web3j = Web3j.build(new HttpService(besuApiUrl));\r\n\r\n    private enum BLOCKCHAIN_TYPE {DATABASE, BESU_ONLY, FABRIC, BESU}\r\n\r\n    private String blockchainType = config.getProperty(\"txn.blockchain.type\", \"BESU\");\r\n    private BLOCKCHAIN_TYPE BLOCKCHAIN_BACKEND = BLOCKCHAIN_TYPE.valueOf(blockchainType);\r\n\r\n    private CloudMessaging cloudMessaging = new CloudMessaging();\r\n\r\n    private String fromAddress;\r\n    private String toAddress;\r\n    private String value;\r\n    private String result;\r\n\r\n    public void setFromAddress(String fromAddress) {\r\n        this.fromAddress = fromAddress;\r\n    }\r\n\r\n    public void setToAddress(String toAddress) {\r\n        this.toAddress = toAddress;\r\n    }\r\n\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n\r\n    public String getResult() {\r\n        return result;\r\n    }\r\n\r\n    private String normalizeHash(String hash) {\r\n        if (hash.startsWith(\"0x\")) {\r\n            return hash.substring(2);\r\n        }\r\n        return hash;\r\n    }\r\n\r\n    private String toHexHash(String hash) {\r\n        if (hash.startsWith(\"0x\")) {\r\n            return hash;\r\n        }\r\n        return \"0x\" + hash;\r\n    }\r\n\r\n    private Optional<TransactionReceipt> sendTransactionReceiptRequest(String transactionHash)\r\n            throws Exception {\r\n        EthGetTransactionReceipt transactionReceipt = web3j\r\n                .ethGetTransactionReceipt(transactionHash)\r\n                .sendAsync()\r\n                .get();\r\n\r\n        return transactionReceipt.getTransactionReceipt();\r\n    }\r\n\r\n    private Optional<TransactionReceipt> getTransactionReceipt(\r\n            String transactionHash, int sleepDuration, int attempts) throws Exception {\r\n        Optional<TransactionReceipt> receiptOptional =\r\n                sendTransactionReceiptRequest(transactionHash);\r\n        for (int i = 0; i < attempts; i++) {\r\n            if (!receiptOptional.isPresent()) {\r\n                Thread.sleep(sleepDuration);\r\n                receiptOptional = sendTransactionReceiptRequest(transactionHash);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return receiptOptional;\r\n    }\r\n\r\n    private TransactionReceipt waitForTransactionReceipt(String transactionHash) throws Exception {\r\n        Optional<TransactionReceipt> transactionReceiptOptional =\r\n                getTransactionReceipt(transactionHash, SLEEP_DURATION, ATTEMPTS);\r\n\r\n        if (!transactionReceiptOptional.isPresent()) {\r\n            throw new BusinessException(\r\n                    \"Transaction receipt not generated after \" + ATTEMPTS + \" attempts\");\r\n        }\r\n        return transactionReceiptOptional.get();\r\n    }\r\n\r\n    private void updateWalletBalances(String from, String to) throws Exception {\r\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, from, Wallet.class);\r\n        Wallet toWallet = crossStorageApi.find(defaultRepo, to, Wallet.class);\r\n\r\n        EthGetBalance toBalance = web3j.ethGetBalance(to, LATEST).sendAsync().get();\r\n        EthGetBalance fromBalance = web3j.ethGetBalance(from, LATEST).sendAsync().get();\r\n\r\n        fromWallet.setBalance(fromBalance.getBalance().toString());\r\n        toWallet.setBalance(toBalance.getBalance().toString());\r\n        crossStorageApi.createOrUpdate(defaultRepo, fromWallet);\r\n        crossStorageApi.createOrUpdate(defaultRepo, toWallet);\r\n    }\r\n\r\n    private String transferDB(String from, String to, BigInteger amount, String type,\r\n                              String description) throws Exception {\r\n        String transactionHash = \"\";\r\n        Wallet toWallet = crossStorageApi.find(defaultRepo, to, Wallet.class);\r\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, from, Wallet.class);\r\n        if (fromWallet.getPrivateKey() == null) {\r\n            throw new Exception(\"wallet has no private key\");\r\n        }\r\n        String privateKey = normalizeHash(fromWallet.getPrivateKey());\r\n\r\n        BigInteger originBalance = new BigInteger(fromWallet.getBalance());\r\n        if (amount.compareTo(originBalance) > 0) {\r\n            throw new BusinessException(INSUFFICIENT_BALANCE);\r\n        }\r\n\r\n        Transaction lastTransaction = crossStorageApi.find(defaultRepo, Transaction.class)\r\n                                                     .by(\"fromHexHash\", fromWallet.getUuid())\r\n                                                     .orderBy(\"nonce\", false) // by largest to smallest\r\n                                                     .getResult();\r\n        BigInteger nonce = BigInteger.ONE;\r\n        if (lastTransaction != null) {\r\n            try {\r\n                nonce = BigInteger.valueOf(Long.parseLong(lastTransaction.getNonce()) + 1);\r\n            } catch (NumberFormatException e) {\r\n                LOG.error(\"invalid nonce :{}\", lastTransaction.getNonce());\r\n            }\r\n        }\r\n\r\n        String recipientAddress = \"0x\" + toWallet.getUuid();\r\n        String data = String.format(TRANSACTION_DATA_FORMAT, type, description);\r\n        BigInteger gasLimit = BigInteger.ZERO;\r\n        BigInteger gasPrice = BigInteger.ZERO;\r\n        RawTransaction rawTransaction = RawTransaction\r\n                .createTransaction(nonce, gasPrice, gasLimit, recipientAddress, amount, data);\r\n        Credentials credentials = Credentials.create(privateKey);\r\n        byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\r\n        String encodedTransaction = Numeric.toHexString(signedMessage);\r\n\r\n        Transaction transaction = new Transaction();\r\n        transactionHash = Hash.sha3(encodedTransaction);\r\n        transaction.setHexHash(normalizeHash(transactionHash));\r\n        transaction.setFromHexHash(fromWallet.getUuid());\r\n        transaction.setToHexHash(toWallet.getUuid());\r\n        transaction.setNonce(\"\" + nonce);\r\n        transaction.setGasPrice(gasPrice.toString());\r\n        transaction.setGasLimit(gasLimit.toString());\r\n        transaction.setValue(amount.toString());\r\n        transaction.setData(data);\r\n        transaction.setType(type);\r\n        transaction.setSignedHash(normalizeHash(encodedTransaction));\r\n        transaction.setCreationDate(java.time.Instant.now());\r\n\r\n        crossStorageApi.createOrUpdate(defaultRepo, transaction);\r\n\r\n        // FIXME: you should get the BlockForgerScript from scriptService\r\n        BlockForgerScript.addTransaction(transaction);\r\n\r\n        return transactionHash;\r\n    }\r\n\r\n    private String transferBesu(String from, String to, BigInteger amount,\r\n                                String type, String description) throws Exception {\r\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, from, Wallet.class);\r\n        String privateKey = fromWallet.getPrivateKey();\r\n        BigInteger balance = BigInteger.ZERO;\r\n\r\n        if (fromWallet.getBalance() == null || fromWallet.getBalance().isEmpty()) {\r\n            balance = web3j.ethGetBalance(from, LATEST).sendAsync().get().getBalance();\r\n\r\n        } else {\r\n            balance = new BigInteger(fromWallet.getBalance());\r\n        }\r\n\r\n        if (balance.compareTo(amount) < 0) {\r\n            throw new BusinessException(INSUFFICIENT_BALANCE);\r\n        }\r\n\r\n        Credentials credentials = Credentials.create(privateKey);\r\n        EthGetTransactionCount ethGetTransactionCount = web3j\r\n                .ethGetTransactionCount(credentials.getAddress(), LATEST)\r\n                .send();\r\n        BigInteger nonce = ethGetTransactionCount.getTransactionCount();\r\n\r\n        org.web3j.protocol.core.methods.request.Transaction transaction =\r\n                org.web3j.protocol.core.methods.request.Transaction\r\n                        .createEtherTransaction(from, nonce, defaultGasPrice,\r\n                                                defaultGasLimit, to, amount);\r\n\r\n        BigInteger estimatedGas = web3j.ethEstimateGas(transaction).send().getAmountUsed();\r\n        LOG.debug(\"estimatedGas: {}\", estimatedGas);\r\n        BigInteger gasPrice = web3j.ethGasPrice().send().getGasPrice();\r\n        LOG.debug(\"gasPrice: {}\", gasPrice);\r\n\r\n        RawTransaction rawTransaction = RawTransaction\r\n                .createEtherTransaction(nonce, gasPrice, defaultGasLimit, to, amount);\r\n\r\n        byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\r\n        String encodedTransaction = Numeric.toHexString(signedMessage);\r\n\r\n        EthSendTransaction ethSendTransaction = web3j\r\n                .ethSendRawTransaction(encodedTransaction)\r\n                .sendAsync()\r\n                .get();\r\n\r\n        String transactionHash = ethSendTransaction.getTransactionHash();\r\n        LOG.debug(\"pending transactionHash: {}\", transactionHash);\r\n\r\n        if (transactionHash == null || transactionHash.isEmpty()) {\r\n            throw new BusinessException(TRANSACTION_FAILED);\r\n        }\r\n\r\n        TransactionReceipt transactionReceipt = waitForTransactionReceipt(transactionHash);\r\n\r\n        String completedTransactionHash = transactionReceipt.getTransactionHash();\r\n        LOG.debug(\"completed transactionHash: {}\", completedTransactionHash);\r\n\r\n        updateWalletBalances(from, to);\r\n\r\n        return completedTransactionHash;\r\n    }\r\n\r\n    private String transferBesuDB(String from, String to, BigInteger amount,\r\n                                  String type, String description) throws Exception {\r\n\r\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, from, Wallet.class);\r\n        Wallet toWallet = crossStorageApi.find(defaultRepo, to, Wallet.class);\r\n\r\n        String privateKey = fromWallet.getPrivateKey();\r\n        BigInteger balance = BigInteger.ZERO;\r\n\r\n        if (fromWallet.getBalance() == null || fromWallet.getBalance().isEmpty()) {\r\n            balance = web3j.ethGetBalance(from, LATEST).sendAsync().get().getBalance();\r\n\r\n        } else {\r\n            balance = new BigInteger(fromWallet.getBalance());\r\n        }\r\n\r\n        if (balance.compareTo(amount) < 0) {\r\n            throw new BusinessException(INSUFFICIENT_BALANCE);\r\n        }\r\n\r\n        Credentials credentials = Credentials.create(privateKey);\r\n        EthGetTransactionCount ethGetTransactionCount = web3j\r\n                .ethGetTransactionCount(credentials.getAddress(), LATEST)\r\n                .send();\r\n        BigInteger nonce = ethGetTransactionCount.getTransactionCount();\r\n\r\n        BigInteger gasPrice = web3j.ethGasPrice().send().getGasPrice();\r\n        LOG.debug(\"gasPrice: {}\", gasPrice);\r\n\r\n        RawTransaction rawTransaction = RawTransaction\r\n                .createEtherTransaction(nonce, gasPrice, defaultGasLimit, to, amount);\r\n\r\n        byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\r\n        String encodedTransaction = Numeric.toHexString(signedMessage);\r\n\r\n        EthSendTransaction ethSendTransaction = web3j\r\n                .ethSendRawTransaction(encodedTransaction)\r\n                .sendAsync()\r\n                .get();\r\n\r\n        String transactionHash = ethSendTransaction.getTransactionHash();\r\n        LOG.debug(\"pending transactionHash: {}\", transactionHash);\r\n\r\n        if (transactionHash == null || transactionHash.isEmpty()) {\r\n            throw new BusinessException(TRANSACTION_FAILED);\r\n        }\r\n\r\n        TransactionReceipt transactionReceipt = waitForTransactionReceipt(transactionHash);\r\n\r\n        String completedTransactionHash = transactionReceipt.getTransactionHash();\r\n        LOG.debug(\"completed transactionHash: {}\", completedTransactionHash);\r\n\r\n        String data = String.format(TRANSACTION_DATA_FORMAT, type, description);\r\n\r\n        Transaction transaction = new Transaction();\r\n        transaction.setHexHash(normalizeHash(completedTransactionHash));\r\n        transaction.setFromHexHash(fromWallet.getUuid());\r\n        transaction.setToHexHash(toWallet.getUuid());\r\n        transaction.setNonce(\"\" + nonce);\r\n        transaction.setGasPrice(gasPrice.toString());\r\n        transaction.setGasLimit(defaultGasLimit.toString());\r\n        transaction.setValue(amount.toString());\r\n        transaction.setData(data);\r\n        transaction.setType(type);\r\n        transaction.setSignedHash(normalizeHash(encodedTransaction));\r\n        transaction.setCreationDate(java.time.Instant.now());\r\n\r\n        crossStorageApi.createOrUpdate(defaultRepo, transaction);\r\n\r\n        updateWalletBalances(from, to);\r\n\r\n        return completedTransactionHash;\r\n    }\r\n\r\n    public String transferSmartContract(String from, String to, BigInteger amount,\r\n                                         String type, String description, String message) throws Exception {\r\n        String sender = normalizeHash(from);\r\n        String recipient = normalizeHash(to);\r\n\r\n        Wallet fromWallet = crossStorageApi.find(defaultRepo, sender, Wallet.class);\r\n        String privateKey = fromWallet.getPrivateKey();\r\n        Credentials credentials = Credentials.create(privateKey);\r\n        BigInteger balance = BigInteger.ZERO;\r\n\r\n        LOG.info(\"transfer amount:{} to:{}\", amount, toHexHash(to));\r\n        RawTransactionManager manager = new RawTransactionManager(web3j, credentials);\r\n        Function function = new Function(\r\n                \"transfer\",\r\n                Arrays.asList(new Address(toHexHash(to)), new Uint256(amount)),\r\n                Arrays.asList(new TypeReference<Bool>() {}));\r\n        String data = FunctionEncoder.encode(function);\r\n\r\n        BigInteger gasPrice = BigInteger.ZERO;\r\n        EthSendTransaction transaction = manager.sendTransaction(\r\n                gasPrice,\r\n                defaultGasLimit,\r\n                smartContract,\r\n                data,\r\n                null);\r\n        String transactionHash = transaction.getTransactionHash();\r\n        LOG.info(\"pending transactionHash: {}\", transactionHash);\r\n\r\n        if (transactionHash == null || transactionHash.isEmpty()) {\r\n            throw new BusinessException(TRANSACTION_FAILED);\r\n        }\r\n\r\n        TransactionReceipt transactionReceipt = waitForTransactionReceipt(transactionHash);\r\n\r\n        String completedTransactionHash = transactionReceipt.getTransactionHash();\r\n        LOG.info(\"completed transactionHash: {}\", completedTransactionHash);\r\n\r\n        //updateWalletBalances(sender, recipient);\r\n        try {\r\n            if (!completedTransactionHash.isEmpty()) {\r\n                cloudMessaging.setUserId(recipient);\r\n                cloudMessaging.setTitle(\"Telecel Play\");\r\n                cloudMessaging.setBody(message);\r\n                cloudMessaging.execute(null);\r\n            }\r\n        } catch (Exception e) {\r\n            LOG.warn(\"cannot send notification to {}: {}\", toAddress, message);\r\n        }\r\n\r\n        return completedTransactionHash;\r\n    }\r\n\r\n    private String transferFabric(String from, String to, BigInteger amount,\r\n                                  String type, String description) throws Exception {\r\n        return \"\";\r\n    }\r\n\r\n    public String transfer(String from, String to, BigInteger amount)\r\n            throws Exception {\r\n        String message = String.format(\r\n                \"You received %s coins !\",\r\n                Convert.fromWei(amount.toString(), Unit.ETHER));\r\n        return transfer(from, to, amount, \"transfer\", \"Transfer coins\", message);\r\n    }\r\n\r\n    public String transfer(String from, String to, BigInteger amount, String type,\r\n                           String description, String message) throws Exception {\r\n        String transactionHash = \"\";\r\n        String recipientAddress = normalizeHash(to);\r\n        String senderAddress = normalizeHash(from);\r\n        switch (BLOCKCHAIN_BACKEND) {\r\n            case BESU_ONLY:\r\n                transactionHash = transferBesu(\r\n                        senderAddress,\r\n                        recipientAddress,\r\n                        amount,\r\n                        type,\r\n                        description);\r\n                break;\r\n            case FABRIC:\r\n                transactionHash = transferFabric(\r\n                        senderAddress,\r\n                        recipientAddress,\r\n                        amount,\r\n                        type,\r\n                        description);\r\n                break;\r\n            case BESU:\r\n                transactionHash = transferBesuDB(\r\n                        from,\r\n                        to,\r\n                        amount,\r\n                        type,\r\n                        description);\r\n                break;\r\n            default:\r\n                transactionHash = transferDB(\r\n                        senderAddress,\r\n                        recipientAddress,\r\n                        amount,\r\n                        type,\r\n                        description);\r\n                break;\r\n        }\r\n        // TODO - send notification to the user e.g. CloudMessaging\r\n        try {\r\n            if (!transactionHash.isEmpty()) {\r\n                cloudMessaging.setUserId(recipientAddress);\r\n                cloudMessaging.setTitle(\"Telecel Play\");\r\n                cloudMessaging.setBody(message);\r\n                cloudMessaging.execute(null);\r\n            }\r\n        } catch (Exception e) {\r\n            LOG.warn(\"cannot send notification to {}: {}\", toAddress, message);\r\n        }\r\n        return transactionHash;\r\n    }\r\n\r\n    // used to transfer from local account\r\n    @Override\r\n    public void execute(Map<String, Object> parameters) throws BusinessException {\r\n        String transactionHash = \"\";\r\n        try {\r\n            transactionHash = transfer(fromAddress, toAddress, new BigInteger(value));\r\n            result = \"{\\\"transaction_hash\\\":\\\"\" + transactionHash + \"\\\"}\";\r\n        } catch (Exception e) {\r\n            LOG.error(\"Transfer error\", e);\r\n            result = \"{\\\"error\\\":\\\"\" + e.getMessage() + \"\\\"}\";\r\n        }\r\n    }\r\n}\r\n\r\nclass HttpService extends Service {\r\n\r\n    public static final String DEFAULT_URL = \"http://localhost:8545/\";\r\n    private static final Logger LOG = LoggerFactory.getLogger(HttpService.class);\r\n\r\n    private Client httpClient;\r\n    private final String url;\r\n    private final boolean includeRawResponse;\r\n    private Map<String, String> headers = new HashMap<>();\r\n\r\n    public HttpService(String url, Client httpClient, boolean includeRawResponse) {\r\n        super(includeRawResponse);\r\n        this.url = url;\r\n        this.httpClient = httpClient;\r\n        this.includeRawResponse = includeRawResponse;\r\n    }\r\n\r\n    public HttpService(Client httpClient, boolean includeRawResponse) {\r\n        this(DEFAULT_URL, httpClient, includeRawResponse);\r\n    }\r\n\r\n    public HttpService(String url, Client httpClient) {\r\n        this(url, httpClient, false);\r\n    }\r\n\r\n    public HttpService(String url) {\r\n        this(url, createHttpClient());\r\n    }\r\n\r\n    public HttpService(String url, boolean includeRawResponse) {\r\n        this(url, createHttpClient(), includeRawResponse);\r\n    }\r\n\r\n    public HttpService(Client httpClient) {\r\n        this(DEFAULT_URL, httpClient);\r\n    }\r\n\r\n    public HttpService(boolean includeRawResponse) {\r\n        this(DEFAULT_URL, includeRawResponse);\r\n    }\r\n\r\n    public HttpService() {\r\n        this(DEFAULT_URL);\r\n    }\r\n\r\n    private static Client createHttpClient() {\r\n        return ClientBuilder.newClient();\r\n    }\r\n\r\n    @Override\r\n    protected InputStream performIO(String request) throws IOException {\r\n\r\n        LOG.debug(\"Request: {}\", request);\r\n\r\n        Response response = null;\r\n        try {\r\n            response = httpClient.target(url)\r\n                                 .request(MediaType.APPLICATION_JSON)\r\n                                 .headers(convertHeaders())\r\n                                 .post(Entity.json(request));\r\n        } catch (ClientConnectionException e) {\r\n            throw new IOException(\"Unable to connect to \" + url, e);\r\n        }\r\n\r\n        if (response.getStatus() != 200) {\r\n            throw new IOException(\r\n                    \"Error \" + response.getStatus() + \": \" + response.readEntity(String.class));\r\n        }\r\n\r\n        if (includeRawResponse) {\r\n            return new BufferedInputStream(response.readEntity(InputStream.class));\r\n        }\r\n\r\n        return new ByteArrayInputStream(response.readEntity(String.class).getBytes());\r\n    }\r\n\r\n    private MultivaluedMap<String, Object> convertHeaders() {\r\n        MultivaluedMap<String, Object> headers = new MultivaluedHashMap<>();\r\n        for (Map.Entry<String, String> entry : this.headers.entrySet()) {\r\n            headers.put(entry.getKey(), Arrays.asList(entry.getValue()));\r\n        }\r\n        return headers;\r\n    }\r\n\r\n    public void addHeader(String key, String value) {\r\n        headers.put(key, value);\r\n    }\r\n\r\n    public void addHeaders(Map<String, String> headersToAdd) {\r\n        headers.putAll(headersToAdd);\r\n    }\r\n\r\n    public Map<String, String> getHeaders() {\r\n        return headers;\r\n    }\r\n\r\n    public String getUrl() {\r\n        return url;\r\n    }\r\n\r\n    @Override\r\n    public void close() throws IOException {}\r\n\r\n}\r\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ {
    "groupId" : "org.web3j",
    "artifactId" : "core",
    "version" : "4.8.9",
    "coordinates" : "org.web3j:core:4.8.9"
  } ],
  "importScriptInstances" : [ {
    "code" : "io.liquichain.core.BlockForgerScript",
    "description" : "Bock forging script",
    "inputs" : [ ],
    "outputs" : [ {
      "name" : "lastBlock",
      "type" : "Block"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package io.liquichain.core;\r\n\r\nimport java.util.Map;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Arrays;\r\nimport java.util.ArrayList;\r\nimport java.math.BigInteger;\r\nimport java.time.Instant;\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\nimport java.util.stream.Collectors;\r\nimport java.io.IOException;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.math.BigInteger;\r\nimport org.meveo.model.customEntities.Block;\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.customEntities.Transaction;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.persistence.CrossStorageService;\r\nimport org.meveo.cache.CustomFieldsCacheContainerProvider;\r\nimport org.meveo.api.exception.EntityDoesNotExistsException;\r\nimport org.meveo.admin.util.pagination.PaginationConfiguration;\r\nimport org.meveo.model.persistence.CEIUtils;\r\nimport org.meveo.service.custom.CustomTableService;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.primefaces.model.SortOrder;\r\n\r\nimport org.web3j.crypto.*;\r\n\r\npublic class BlockForgerScript extends Script {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(BlockForgerScript.class);\r\n  \r\n    private static long chainId=76;\r\n\r\n    private int networkId = 7;\r\n\r\n    static public long blockHeight = 1;\r\n  \r\n    private Block parentBlock=null;\r\n    \r\n    private String exampleBlock = \"{\" +\r\n      \"\\\"difficulty\\\":\\\"0x5\\\",\" +\r\n      \"\\\"extraData\\\":\\\"0xd58301090083626f7286676f312e3133856c696e75780000000000000000000021c9effaf6549e725463c7877ddebe9a2916e03228624e4bfd1e3f811da792772b54d9e4eb793c54afb4a29f014846736755043e4778999046d0577c6e57e72100\\\",\"\r\n      + \"\\\"gasLimit\\\":\\\"0xe984c2\\\",\" + \"\\\"gasUsed\\\":\\\"0x0\\\",\" \r\n      + \"\\\"hash\\\":\\\"0xaa14340feb15e26bc354bb839b2aa41cc7984676249c155ac5e4d281a8d08809\\\",\"\r\n      + \"\\\"logsBloom\\\":\\\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\\",\"\r\n      + \"\\\"miner\\\":\\\"0x0000000000000000000000000000000000000000\\\",\" +\r\n      \"\\\"mixHash\\\":\\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\",\" +\r\n      \"\\\"nonce\\\":\\\"0x0000000000000000\\\",\" +\r\n      \"\\\"number\\\":\\\"0x1b4\\\",\" +\r\n      \"\\\"parentHash\\\":\\\"0xc8ccb81f484a428a3a1669d611f55f880b362b612f726711947d98f5bc5af573\\\",\" + \r\n      \"\\\"receiptsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" +\r\n      \"\\\"sha3Uncles\\\":\\\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\\\",\" +\r\n      \"\\\"size\\\":\\\"0x260\\\",\" +\r\n      \"\\\"stateRoot\\\":\\\"0xffcb834d62706995e9e7bf10cc9a9e42a82fea998d59b3a5cfad8975dbfe3f87\\\",\" +\r\n      \"\\\"timestamp\\\":\\\"0x5ed9a43f\\\",\" +\r\n      \"\\\"totalDifficulty\\\":\\\"0x881\\\",\" +\r\n      \"\\\"transactions\\\":[\" + \"],\" + \r\n      \"\\\"transactionsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" + \r\n      \"\\\"uncles\\\":[  \" + \"]}\";\r\n\r\n      \r\n\tprivate CustomFieldsCacheContainerProvider cetCache = getCDIBean(CustomFieldsCacheContainerProvider.class);\r\n    private CrossStorageService crossStorageService = getCDIBean(CrossStorageService.class);\r\n    private CustomTableService customTableService = getCDIBean(CustomTableService.class);\r\n    \r\n    private static PaginationConfiguration lastBlockPC = new PaginationConfiguration(\"blockNumber\",SortOrder.DESCENDING);\r\n  \r\n  \tprivate CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\r\n\r\n    \r\n    private static List<Transaction> currentTransactions = new ArrayList<>();\r\n    private static List<Transaction> nextTransactions = new ArrayList<>();\r\n  \r\n    private static Instant nextBlockDate;\r\n    private static AtomicBoolean isForging = new AtomicBoolean(false);\r\n  \r\n    public static void addTransaction(Transaction t){\r\n      if(isForging.get()){\r\n          nextTransactions.add(t);\r\n      } else {\r\n          currentTransactions.add(t);\r\n      }\r\n    }\r\n  \r\n    public Block getLastBlock(){\r\n        Block result = null;\r\n        try{\r\n            //log.info(\"query : \"+customTableService.getQuery(\"block\", lastBlockPC));\r\n        List<Map<String, Object>> res = crossStorageService.find(defaultRepo, cetCache.getCustomEntityTemplate(\"Block\"), lastBlockPC);\r\n        if(res.size()>0){\r\n            result = CEIUtils.deserialize(res.get(0), Block.class);\r\n            //log.info(\"lastBlock number:{}\",result.getBlockNumber());\r\n        }\r\n        } catch(Exception e){\r\n          log.error(\"getLastBlock:{}\",e);\r\n        }\r\n        return result;\r\n    }\r\n  \r\n    @Override\r\n    public void execute(Map<String, Object> parameters) throws BusinessException {\r\n      //log.info(\"execute forging\");\r\n      if(parentBlock==null){\r\n      \t//log.info(\"retreive last block from chain\");\r\n        parentBlock = getLastBlock();\r\n      }\r\n      if(isForging.getAndSet(true)){\r\n         log.error(\"we are already forging\");\r\n         return;\r\n      } \r\n      if(currentTransactions.size()==0){\r\n        //log.info(\"no transaction to forge\");\r\n        blockHeight=parentBlock.getBlockNumber();\r\n        isForging.set(false);\r\n        return;\r\n      } else {\r\n        log.info(\"forging {} transactions\",currentTransactions.size());\r\n        Map<String,Wallet> wallets = new HashMap<>();\r\n        List<Transaction> orderedTransactions = currentTransactions.stream().sorted((t1,t2)->(t1.getCreationDate().compareTo(t2.getCreationDate()))).collect(Collectors.toList());\r\n        \r\n        blockHeight=parentBlock.getBlockNumber()+1;\r\n        \r\n        String transactionHashes=\"\";\r\n        List<Transaction> invalidTransactions = new ArrayList<>();\r\n        for(Transaction t: currentTransactions){\r\n          log.info(\" transaction date : {}\",t.getCreationDate());\r\n          if(!wallets.containsKey(t.getFromHexHash())){\r\n            try{\r\n            \tWallet originWallet = crossStorageApi.find(defaultRepo,t.getFromHexHash(), Wallet.class);\r\n                log.info(\"add originWallet:{} {} to map\",originWallet.getUuid(),originWallet.getBalance());\r\n                wallets.put(t.getFromHexHash(),originWallet);\r\n            } catch(Exception e){\r\n              log.info(\" cannot find origin wallet, set blockNumber to INVALID\");\r\n              t.setBlockNumber(\"INVALID\");\r\n              try {\r\n              crossStorageApi.createOrUpdate(defaultRepo, t);\r\n              } catch(Exception ex){\r\n                ex.printStackTrace();\r\n              }\r\n              invalidTransactions.add(t);\r\n            }\r\n          }\r\n          if(t.getBlockNumber() == null){\r\n            Wallet originWallet = wallets.get(t.getFromHexHash());\r\n          \tlog.info(\"originWallet 0x{} old balance:{}\",t.getFromHexHash(),originWallet.getBalance());\r\n            BigInteger transacValue = new BigInteger(t.getValue());\r\n          \tif(new BigInteger(originWallet.getBalance()).compareTo(transacValue)>=0){\r\n                originWallet.setBalance(\"\"+new BigInteger(originWallet.getBalance()).add(transacValue.negate()));\r\n                try{\r\n            \t\tWallet destinationWallet = crossStorageApi.find(defaultRepo,t.getToHexHash(), Wallet.class);\r\n          \t\t\tlog.info(\"destinationWallet 0x{} old balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\r\n                    destinationWallet.setBalance(\"\"+new BigInteger(destinationWallet.getBalance()).add(transacValue));\r\n          \t\t\tcrossStorageApi.createOrUpdate(defaultRepo, destinationWallet);\r\n          \t\t\tlog.info(\"destinationWallet 0x{} new balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\r\n          \t\t\ttransactionHashes+=t.getHexHash();\r\n                } catch(Exception e){\r\n              \t\tlog.info(\" cannot find destination wallet, set blockNumber to INVALID\");\r\n              \t\tt.setBlockNumber(\"INVALID\");\r\n              \t\ttry{\r\n\t\t\t\t\t\tcrossStorageApi.createOrUpdate(defaultRepo, t);\r\n                    } catch(Exception ex){\r\n                \t\tex.printStackTrace();\r\n              \t\t}\r\n              \t\tinvalidTransactions.add(t);\r\n                }\r\n          \t} else {\r\n              log.info(\"insufficient balance, set blockNumber to INVALID\");\r\n              t.setBlockNumber(\"INVALID\");\r\n              try{\r\n              \tcrossStorageApi.createOrUpdate(defaultRepo, t);\r\n              } catch(Exception ex){\r\n                ex.printStackTrace();\r\n              }\r\n              invalidTransactions.add(t);\r\n            }\r\n          }\r\n        }\r\n        currentTransactions.removeAll(invalidTransactions);\r\n        Block block =  new Block();\r\n        block.setCreationDate(Instant.now());\r\n        \r\n        //FIXME parent should not be null\r\n        block.setParentHash(parentBlock==null?\"\":parentBlock.getHash());\r\n        block.setSize((long)currentTransactions.size());\r\n        \r\n        //FIXME hash parent hash\r\n        block.setHash(Hash.sha3(transactionHashes).substring(2));\r\n        \r\n        block.setBlockNumber(blockHeight);\r\n        try{\r\n          crossStorageApi.createOrUpdate(defaultRepo, block);\r\n          long i=0;\r\n          for(Transaction t: currentTransactions){\r\n              Wallet originWallet = wallets.get(t.getFromHexHash());\r\n              log.info(\"originWallet 0x{} new balance:{}\",t.getFromHexHash(),originWallet.getBalance());\r\n              crossStorageApi.createOrUpdate(defaultRepo, originWallet);\r\n              t.setBlockHash(block.getHash());\r\n              t.setBlockNumber(\"\"+block.getBlockNumber());\r\n              t.setTransactionIndex(i++);\r\n              crossStorageApi.createOrUpdate(defaultRepo, t);\r\n          }\r\n\r\n          parentBlock=block;\r\n          currentTransactions = nextTransactions;\r\n          nextTransactions = new ArrayList<>();\r\n        } catch(Exception ex){\r\n            ex.printStackTrace();\r\n        }\r\n        \r\n        isForging.set(false);\r\n      }\r\n    }\r\n  \r\n}\r\n",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ {
      "groupId" : "org.web3j",
      "artifactId" : "core",
      "version" : "4.8.9",
      "coordinates" : "org.web3j:core:4.8.9"
    } ],
    "importScriptInstances" : [ ]
  }, {
    "code" : "org.meveo.firebase.CloudMessaging",
    "description" : "Send notification and register users",
    "inputs" : [ {
      "name" : "userId",
      "type" : "String"
    }, {
      "name" : "title",
      "type" : "String"
    }, {
      "name" : "body",
      "type" : "String"
    } ],
    "outputs" : [ {
      "name" : "result",
      "type" : "String"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package org.meveo.firebase;\r\n\r\nimport java.util.Map;\r\nimport java.time.OffsetDateTime;\r\nimport java.time.Instant;\r\n\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException; \r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport javax.ws.rs.client.*;\r\nimport javax.ws.rs.core.*;\r\nimport com.google.gson.*;\r\n\r\nimport org.meveo.model.customEntities.Credential;\r\nimport org.meveo.model.customEntities.FCMToken;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.credentials.CredentialHelperService;\r\nimport org.meveo.model.persistence.CEIUtils;\r\nimport org.apache.commons.codec.digest.DigestUtils;\r\n\r\npublic class CloudMessaging extends Script {\r\n\r\n\tprivate static final Logger log = LoggerFactory.getLogger(CloudMessaging.class);\r\n\tprivate CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n\tprivate RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n\tprivate Repository defaultRepo = repositoryService.findDefaultRepository();\r\n\r\n\tstatic final private String FCM_DOMAIN = \"fcm.googleapis.com\";\r\n\r\n\tprivate String userId;\r\n\tprivate String title;\r\n\tprivate String body;\r\n\tprivate String result;\r\n\r\n\tpublic void setUserId(String userId){\r\n\t\tthis.userId = userId;\r\n\t}\r\n\r\n\tpublic void setTitle(String title){\r\n\t\tthis.title = title;\r\n\t}\r\n\t\r\n\tpublic void setBody(String body){\r\n\t\tthis.body = body;\r\n\t}\r\n  \r\n    public String getResult(){\r\n        return result;\r\n    }\r\n\r\n\t@Override\r\n\tpublic void execute(Map<String, Object> parameters) throws BusinessException {\r\n\t\tCredential credential = CredentialHelperService.getCredential(FCM_DOMAIN, crossStorageApi, defaultRepo);\r\n\t\tif (credential == null) {\r\n\t\t\tthrow new BusinessException(\"No credential found for \" + FCM_DOMAIN);\r\n\t\t} else {\r\n\t\t\tlog.info(\"using credential {} with username {}\", credential.getUuid(), credential.getUsername());\r\n\t\t}\r\n\t\tFCMToken token = null;\r\n\t\ttry{ \r\n\t\t\ttoken = crossStorageApi.find(defaultRepo,FCMToken.class).by(\"userId\",userId).getResult();\r\n\t\t} catch (Exception e){\r\n\t\t\tthrow new BusinessException(\"TOKEN_NOT_FOUND\");\r\n\t\t}\r\n\t\tClient client = ClientBuilder.newClient();\r\n\t\tclient.register(new CredentialHelperService.LoggingFilter());\r\n\t\tWebTarget target = client.target(\"https://fcm.googleapis.com/fcm/send\");\r\n      String notification = \"{\\n\"\r\n\t\t+\"\\\"title\\\": \\\"\"+title+\"\\\",\\n\"\r\n\t\t+\"\\\"body\\\": \\\"\"+body+\"\\\",\\n\"\r\n\t\t+\"}\";\r\n      String data =  \"{\"\r\n\t\t+\"\\\"userId\\\": \\\"\"+userId+\"\\\"\"\r\n\t\t+\"}\";\r\n\t\tString reqBody = \"{\\n\"\r\n\t\t+\"\\\"to\\\": \\\"\"+token.getToken()+\"\\\",\\n\"\r\n\t\t+\"\\\"title\\\": \\\"\"+title+\"\\\",\\n\"\r\n\t\t+\"\\\"body\\\": \\\"\"+body+\"\\\",\\n\"\r\n\t\t+\"\\\"notification\\\": \"+notification+\",\\n\"\r\n\t\t+\"\\\"data\\\": \"+data+\"\\n\"\r\n\t\t+\"}\";\r\n      log.info(\"out :{}\", reqBody);\r\n\t\tResponse response = CredentialHelperService.setCredential(target.request(), credential).post(Entity.json(reqBody));\r\n\t\tresult = response.readEntity(String.class);\r\n\t\tlog.info(\"response  :\" + result);\r\n\t}\r\n\r\n}",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ ],
    "importScriptInstances" : [ {
      "code" : "org.meveo.credentials.CredentialHelperService",
      "description" : "Helper function to build request with credentials",
      "inputs" : [ ],
      "outputs" : [ ],
      "generateOutputs" : false,
      "type" : "JAVA",
      "transactionType" : "SAME",
      "script" : "package org.meveo.credentials;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport javax.ws.rs.client.*;\r\n\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport org.meveo.model.customEntities.Credential;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.elresolver.ValueExpressionWrapper;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\npublic class CredentialHelperService extends Script {\r\n  \r\n  private static final Logger log = LoggerFactory.getLogger(CredentialHelperService.class);\r\n\r\n    public static class LoggingFilter implements ClientRequestFilter {\r\n        @Override\r\n        public void filter(ClientRequestContext requestContext) throws IOException {\r\n            if(requestContext!=null){\r\n              if(requestContext.getEntity()!=null){\r\n                log.info(requestContext.getEntity().toString());\r\n              } else {\r\n                log.info(\"uri:{}\",requestContext.getUri());\r\n              }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static Credential getCredential(String domain,CrossStorageApi crossStorageApiInstance,Repository repo){\r\n      List<Credential> matchigCredentials = crossStorageApiInstance.find(repo, Credential.class)\r\n                .by(\"domainName\", domain)\r\n\t\t\t\t.getResults();\r\n      if(matchigCredentials.size()>0){\r\n        return matchigCredentials.get(0);\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n  \r\n    public static Invocation.Builder setCredential(Invocation.Builder invocBuilder,Credential credential) throws BusinessException {\r\n      String headerKey = credential.getHeaderKey();\r\n      String headerValue = credential.getHeaderValue();\r\n      try{\r\n        if(headerKey.contains(\"#{\")){\r\n          headerKey=ValueExpressionWrapper.evaluateToStringMultiVariable(headerKey,\"entity\",credential);\r\n        }\r\n        if(headerValue.contains(\"#{\")){\r\n          headerValue=ValueExpressionWrapper.evaluateToStringMultiVariable(headerValue,\"entity\",credential);\r\n        }\r\n      } catch(Exception e) {\r\n        throw new BusinessException(e);\r\n      }\r\n      return invocBuilder.header(headerKey, headerValue);\r\n    }\r\n  \r\n\t@Override\r\n\tpublic void execute(Map<String, Object> parameters) throws BusinessException {\r\n    }\r\n\t\r\n}",
      "executionRoles" : [ ],
      "sourcingRoles" : [ ],
      "mavenDependencies" : [ ],
      "importScriptInstances" : [ ]
    } ]
  } ]
}