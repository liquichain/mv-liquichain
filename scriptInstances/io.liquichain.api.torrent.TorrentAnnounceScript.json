{
  "code" : "io.liquichain.api.torrent.TorrentAnnounceScript",
  "description" : "handle torrent announces",
  "inputs" : [ {
    "name" : "peer_id",
    "type" : "String"
  }, {
    "name" : "info_hash",
    "type" : "String"
  }, {
    "name" : "port",
    "type" : "String"
  }, {
    "name" : "downloaded",
    "type" : "String"
  }, {
    "name" : "uploaded",
    "type" : "String"
  }, {
    "name" : "left",
    "type" : "String"
  }, {
    "name" : "event",
    "type" : "String"
  }, {
    "name" : "compact",
    "type" : "String"
  }, {
    "name" : "url",
    "type" : "String"
  }, {
    "name" : "wallet_id",
    "type" : "String"
  }, {
    "name" : "liveness",
    "type" : "String"
  }, {
    "name" : "sign",
    "type" : "String"
  }, {
    "name" : "latitude",
    "type" : "String"
  }, {
    "name" : "longitude",
    "type" : "String"
  } ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.torrent;\n\nimport org.meveo.model.crm.custom.*;\nimport javax.persistence.*;\nimport org.meveo.commons.utils.ReflectionUtils;\nimport java.lang.reflect.*;\nimport java.math.BigInteger;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.stream.Stream;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.time.Instant;\nimport java.time.Duration;\nimport org.meveo.service.script.Script;\nimport org.meveo.admin.exception.BusinessException;\nimport org.meveo.api.rest.technicalservice.impl.EndpointRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.web3j.utils.Strings;\n\nimport java.net.URLDecoder;\n\nimport org.meveo.model.customEntities.Wallet;\nimport org.meveo.model.customEntities.LiquichainApp;\nimport org.meveo.model.customEntities.TorrentAnnounce;\nimport org.meveo.model.storage.Repository;\nimport org.meveo.service.storage.RepositoryService;\nimport org.meveo.api.persistence.CrossStorageApi;\nimport org.meveo.api.persistence.CrossStorageRequest;\nimport org.meveo.model.customEntities.CustomEntityInstance;\nimport org.meveo.model.persistence.CEIUtils;\nimport org.meveo.api.exception.EntityDoesNotExistsException;\n\nimport javax.enterprise.context.ApplicationScoped;\n\n@ApplicationScoped\npublic class TorrentAnnounceScript extends Script {\n\n  private static final Logger log = LoggerFactory.getLogger(TorrentAnnounceScript.class);\n\n  /**\n   * Calculate distance between two points in latitude and longitude.\n   * Uses Haversine method as its base.\n   * \n   * lat1, lon1 Start point lat2, lon2 End point \n   * @returns Distance in Meters\n   */\n  public static double distance(double lat1, double lon1, double lat2, double lon2) {\n\n    final int R = 6371; // Radius of the earth\n\n    double latDistance = Math.toRadians(lat2 - lat1);\n    double lonDistance = Math.toRadians(lon2 - lon1);\n    double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)\n            + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))\n            * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    double distance = R * c * 1000; // convert to meters\n    log.info(\"dist {},{},{},{}:{}\",lat1, lon1, lat2, lon2,distance);\n    return distance;\n  }\n\n  private class DistanceComparator implements Comparator<TorrentAnnounce> {\n\n    double lat, lon;\n\n    public DistanceComparator(double lat, double lon){\n      this.lat=lat;\n      this.lon=lon;\n    }\n\n    @Override\n    public int compare(TorrentAnnounce o1, TorrentAnnounce o2) {\n      int distance = (int)Math.round(distance(lat, lon,o1.getLatitude(),o1.getLongitude())-distance(lat, lon,o2.getLatitude(),o2.getLongitude()));\n      log.info(\"compare {},{}:{}\",o1.getPeerId(), o2.getPeerId(),distance);\n      return distance;\n    }\n  }\n\n  private String peer_id;\n  private String info_hash;\n  private String port;\n  private String downloaded;\n  private String uploaded;\n  private String left;\n  private String event;\n  private String compact;\n  private String url;\n  private String wallet_id;\n  private String liveness;\n  private String sign;\n  private String latitude;\n  private String longitude;\n\n  private String result;\n\n  private CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\n  private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\n  private Repository defaultRepo = repositoryService.findDefaultRepository();\n\n  private String projectId;\n\n  public String getResult() {\n    return result;\n  }\n\n  public void setPeer_id(String value) {\n    if (value.startsWith(\"0x\")) {\n      peer_id = value.substring(2);\n    } else {\n      peer_id = value;\n    }\n  }\n\n  public void setInfo_hash(String value) {\n    if (value.startsWith(\"0x\")) {\n      info_hash = value.substring(2);\n    } else {\n      info_hash = value;\n    }\n  }\n\n  public void setPort(String value) {\n    port = value;\n  }\n\n  public void setDownloaded(String value) {\n    downloaded = value;\n  }\n\n  public void setUploaded(String value) {\n    uploaded = value;\n  }\n\n  public void setLeft(String value) {\n    left = value;\n  }\n\n  public void setEvent(String value) {\n    event = value;\n  }\n\n  public void setCompact(String value) {\n    compact = value;\n  }\n\n  public void setUrl(String value) {\n    url = value;\n  }\n\n  @Deprecated\n  public void setWallet_id(String value) {\n    wallet_id = value;\n  }\n\n  public void setLiveness(String value) {\n    liveness = value;\n  }\n\n  public void setSign(String value) {\n    sign = value;\n  }\n\n  public void setLatitude(String value) {\n    latitude = value;\n  }\n  \n  public void setLongitude(String value) {\n    longitude = value;\n  }\n\n  private void parseQueryString(String qs) {\n    String[] params = qs.split(\"&\");\n    for (String param : params) {\n      if (param.startsWith(\"info_hash=\")) {\n        if (info_hash.length() != 40) {\n          String infoHash = param.substring(10);\n          try {\n            infoHash = URLDecoder.decode(infoHash, \"ISO-8859-1\");\n            info_hash = String.format(\"%x\", new BigInteger(1, infoHash.getBytes()));\n            log.info(\"info_hash={}\", info_hash);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n        }\n      }\n      if (param.startsWith(\"peer_id=\")) {\n        if (peer_id.length() != 40) {\n          String peerId = param.substring(10);\n          try {\n            peerId = URLDecoder.decode(peerId, \"ISO-8859-1\");\n            peer_id = String.format(\"%x\", new BigInteger(1, peerId.getBytes()));\n            log.info(\"peer_id={}\", peer_id);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n        }\n      }\n      if (param.startsWith(\"wallet_id=\")) {\n        if (wallet_id.length() != 40) {\n          String walletId = param.substring(10);\n          try {\n            walletId = URLDecoder.decode(walletId, \"ISO-8859-1\");\n            wallet_id = String.format(\"%x\", new BigInteger(1, walletId.getBytes()));\n            log.info(\"wallet_id={}\", wallet_id);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n        }\n      }\n    }\n  }\n\n  public static String unHex(String arg) {\n\n    String str = \"\";\n    for (int i = 0; i < arg.length(); i += 2) {\n      String s = arg.substring(i, (i + 2));\n      int decimal = Integer.parseInt(s, 16);\n      str = str + (char) decimal;\n    }\n    return str;\n  }\n\n  private static Object getIdValue(Object object) {\n    return ReflectionUtils.getAllFields(new ArrayList<>(), object.getClass()).stream()\n        .filter(f -> f.getAnnotation(Id.class) != null).findFirst().map(f -> {\n          try {\n            f.setAccessible(true);\n            return f.get(object);\n          } catch (IllegalArgumentException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n          }\n        }).orElse(null);\n  }\n\n  private static String getFieldForGetter(Class<?> clazz, Method getter) {\n    String fieldName;\n    if (getter.getName().startsWith(\"is\")) {\n      fieldName = getter.getName().substring(2);\n    } else {\n      fieldName = getter.getName().substring(3);\n    }\n\n    return ReflectionUtils.getAllFields(new ArrayList<>(), clazz).stream()\n        .filter(f -> f.getName().toUpperCase().equals(fieldName.toUpperCase())).findFirst().map(Field::getName)\n        .orElse(null);\n  }\n\n  @Override\n  public void execute(Map<String, Object> parameters) throws BusinessException {\n    // if wallet_id is set then peer_id is the device id, else the peer_id is the\n    // wallet_id\n    log.info(\n        \"Received announce: peer_id:{}, info_hash:{}, port:{}, downloaded:{}, uploaded:{}, left:{}, event:{}, compact:{}, wallet_id:{}, liveness:{},sign:{}\",\n        peer_id, info_hash, port, downloaded, uploaded, left, event, compact, wallet_id, liveness, sign);\n    log.info(\"Received announce: {}\", parameters);\n    // fix the decoding of info_hash and peer_id using correct charset in case they\n    // where not sent in 40 chars hexa\n    EndpointRequest req = (EndpointRequest) parameters.get(\"request\");\n    boolean outputJson = \"application/json\".equals(req.getHeader(\"Accept\"));\n    log.info(\"announce output json: {}\", outputJson);\n    if ((info_hash.length() != 40) || (peer_id.length() != 40)) {\n      parseQueryString(req.getQueryString());\n    }\n    wallet_id = peer_id;\n    // lookup wallet with id walletId\n    Wallet wallet = null;\n    try {\n      if (outputJson) {\n        result = \"{\\\"error\\\":\\\"cannot find wallet\\\"}\";\n      } else {\n        result = \"d14:failure reason27:cannot find wallet.e\";\n      }\n      wallet = crossStorageApi.find(defaultRepo, Wallet.class).by(\"hexHash\", wallet_id).getResult();\n    } catch (Exception e) {\n      throw new BusinessException(result);\n    }\n    log.info(\"found wallet {}\", wallet);\n\n    // retrieve ongoing announce\n    TorrentAnnounce announce = null;\n    List<TorrentAnnounce> announces = crossStorageApi.find(defaultRepo, TorrentAnnounce.class).by(\"peerId\",\n    peer_id).by(\"infoHash\", info_hash).by(\"status\", \"ONGOING\").getResults();\n\n    // events can be started,update,stopped,completed\n    // TODO: if announce is too old then it should be closed and a new on created\n    if (announces.size() > 0) {\n      // TODO: handle case where there is more than one announce, the old ones should\n      // be closed\n      announce = announces.get(0);\n    } else if (!\"stopped\".equals(event)) {\n      announce = new TorrentAnnounce();\n      announce.setPeerId(peer_id);\n      announce.setInfoHash(info_hash);\n      announce.setAnounceDate(Instant.now());\n    } else {\n      if (outputJson) {\n        result = \"{\\\"error\\\":\\\"cannot find announce to close\\\"}\";\n      } else {\n        result = \"d14:failure reason30:cannot find announce to close.e\";\n      }\n      throw new BusinessException(result);\n    }\n    announce.setLastAnnounceDate(Instant.now());\n    announce.setIp(req.getRemoteAddr());\n    boolean coordinateSet=true;\n    try {\n      if (!Strings.isEmpty(port)) {\n        announce.setPort(Long.parseLong(port));\n      }\n      if (!Strings.isEmpty(downloaded)) {\n        announce.setDownloaded(Long.parseLong(downloaded));\n      }\n      if (!Strings.isEmpty(uploaded)) {\n        announce.setUploaded(Long.parseLong(uploaded));\n      }\n      if (!Strings.isEmpty(left)) {\n        announce.setLeft(Long.parseLong(left));\n      }\n      if (!Strings.isEmpty(liveness)) {\n        announce.setLiveness(Double.parseDouble(liveness));\n      }\n      if (!Strings.isEmpty(latitude)) {\n        announce.setLatitude(Double.parseDouble(latitude));\n        if(announce.getLatitude()==0.0){\n          coordinateSet=false;\n        }\n      } else {\n        coordinateSet=false;\n      }\n      if (!Strings.isEmpty(longitude)) {\n        announce.setLongitude(Double.parseDouble(longitude));\n        if(announce.getLongitude()==0.0){\n          coordinateSet=false;\n        }\n      } else {\n        coordinateSet=false;\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n    announce.setUrl(url);\n    if (\"stopped\".equalsIgnoreCase(event)) {\n      announce.setStatus(\"CLOSED\");\n    } else {\n      announce.setStatus(\"ONGOING\");\n    }\n    try {\n      String uuid = crossStorageApi.createOrUpdate(defaultRepo, announce);\n      log.info(\"announce instance {} created / updated\", uuid);\n\n      try {\n        if (outputJson) {\n          result = \"{\\\"error\\\":\\\"cannot find peers\\\"}\";\n        } else {\n          result = \"d14:failure reason18:cannot find peers.e\";\n        }\n        CrossStorageRequest<TorrentAnnounce> csreqlist =crossStorageApi.find(defaultRepo, TorrentAnnounce.class).by(\"status\", \"ONGOING\")\n        .by(\"infoHash\", info_hash);\n        List<TorrentAnnounce> peers = csreqlist.getResults();\n        List<TorrentAnnounce> peersToDelete = new ArrayList<>();\n        for (TorrentAnnounce peer : peers) {\n          if(Duration.between(peer.getLastAnnounceDate(),Instant.now()).compareTo( Duration.ofMinutes( 10 ) )> 0){\n            peersToDelete.add(peer);\n          }\n        }\n        peers.removeAll(peersToDelete);\n        if(coordinateSet){\n          //order peers by increasing distance if the current announce has coordinates\n          DistanceComparator comp = new DistanceComparator(announce.getLatitude(),announce.getLongitude());\n          Collections.sort(peers,comp);\n        } else {\n          //else order peers by most recent first\n          peers.sort((TorrentAnnounce p1, TorrentAnnounce p2) -> p1.getLastAnnounceDate().compareTo(p2.getLastAnnounceDate()));\n        }\n        if (peers.size() > 0) {\n          if (outputJson) {\n            result = \"{\\\"interval\\\":900,\\n\\\"peers\\\":[\";\n          } else {\n            result = \"d8:intervali900e5:peersl\";\n          }\n          String sep = \"\";\n          for (TorrentAnnounce peer : peers) {\n            if(!peer.getPeerId().equals(peer_id)){\n              if (outputJson) {\n                result += sep + \"\\n\";\n                sep = \",\";\n                result += \"{\\\"peer_id\\\":\\\"\" + peer.getPeerId() + \"\\\",\\n\";\n                result += \" \\\"ip\\\":\\\"\" + peer.getIp() + \"\\\",\\n\";\n                result += \" \\\"port\\\":\" + peer.getPort() + \",\\n\";\n                result += \" \\\"uploaded\\\":\" + peer.getUploaded() + \",\\n\";\n                result += \" \\\"latitude\\\":\" + peer.getLatitude() + \",\\n\";\n                result += \" \\\"longitude\\\":\" + peer.getLongitude() + \",\\n\";\n                result += \" \\\"liveness\\\":\" + peer.getLiveness() + \"}\";\n              } else {\n                String peerid = unHex(peer.getPeerId());\n                result += \"d7:peer_id\" + peerid.length() + \":\" + peerid;\n                result += \"2:ip\" + peer.getIp().length() + \":\" + peer.getIp();\n                result += \"4:port\" + (peer.getPort() + \"\").length() + \":i\" + peer.getPort() + \"ee\";\n              }\n            }\n          }\n          if (outputJson) {\n            result += \"]}\";\n          } else {\n            result += \"e\";\n          }\n        }\n        if (peersToDelete.size() > 0) {\n          for(TorrentAnnounce peer : peersToDelete){\n            try{\n              crossStorageApi.remove(defaultRepo,  peer.getUuid(),TorrentAnnounce.class);\n            } catch(Exception e){\n              e.printStackTrace();\n            }\n          }\n        }\n      } catch (Exception e) {\n        throw new BusinessException(result);\n      }\n    } catch (Exception ex) {\n      throw new BusinessException(ex);\n    }\n    \n  }\n\n}\n",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ {
    "groupId" : "org.web3j",
    "artifactId" : "core",
    "version" : "4.8.9",
    "coordinates" : "org.web3j:core:4.8.9"
  } ],
  "importScriptInstances" : [ ]
}