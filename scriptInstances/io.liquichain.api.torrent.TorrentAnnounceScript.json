{
  "code" : "io.liquichain.api.torrent.TorrentAnnounceScript",
  "description" : "handle torrent announces",
  "inputs" : [ {
    "name" : "peer_id",
    "type" : "String"
  }, {
    "name" : "info_hash",
    "type" : "String"
  }, {
    "name" : "port",
    "type" : "String"
  }, {
    "name" : "downloaded",
    "type" : "String"
  }, {
    "name" : "uploaded",
    "type" : "String"
  }, {
    "name" : "left",
    "type" : "String"
  }, {
    "name" : "event",
    "type" : "String"
  }, {
    "name" : "compact",
    "type" : "String"
  }, {
    "name" : "url",
    "type" : "String"
  }, {
    "name" : "wallet_id",
    "type" : "String"
  }, {
    "name" : "liveness",
    "type" : "String"
  }, {
    "name" : "sign",
    "type" : "String"
  }, {
    "name" : "latitude",
    "type" : "String"
  }, {
    "name" : "longitude",
    "type" : "String"
  } ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.torrent;\r\n\r\nimport org.meveo.model.crm.custom.*;\r\nimport javax.persistence.*;\r\nimport org.meveo.commons.utils.ReflectionUtils;\r\nimport java.lang.reflect.*;\r\nimport java.math.BigInteger;\r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\nimport java.util.Map;\r\nimport java.util.HashMap;\r\nimport java.util.stream.Stream;\r\nimport java.util.Comparator;\r\nimport java.util.Collections;\r\nimport java.time.Instant;\r\nimport java.time.Duration;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.meveo.api.rest.technicalservice.impl.EndpointRequest;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.web3j.utils.Strings;\r\n\r\nimport java.net.URLDecoder;\r\n\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.customEntities.LiquichainApp;\r\nimport org.meveo.model.customEntities.TorrentAnnounce;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.api.persistence.CrossStorageRequest;\r\nimport org.meveo.model.customEntities.CustomEntityInstance;\r\nimport org.meveo.model.persistence.CEIUtils;\r\nimport org.meveo.api.exception.EntityDoesNotExistsException;\r\n\r\nimport javax.enterprise.context.ApplicationScoped;\r\n\r\n@ApplicationScoped\r\npublic class TorrentAnnounceScript extends Script {\r\n\r\n  private static final Logger log = LoggerFactory.getLogger(TorrentAnnounceScript.class);\r\n\r\n  /**\r\n   * Calculate distance between two points in latitude and longitude.\r\n   * Uses Haversine method as its base.\r\n   * \r\n   * lat1, lon1 Start point lat2, lon2 End point \r\n   * @returns Distance in Meters\r\n   */\r\n  public static double distance(double lat1, double lon1, double lat2, double lon2) {\r\n\r\n    final int R = 6371; // Radius of the earth\r\n\r\n    double latDistance = Math.toRadians(lat2 - lat1);\r\n    double lonDistance = Math.toRadians(lon2 - lon1);\r\n    double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)\r\n            + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))\r\n            * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);\r\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    double distance = R * c * 1000; // convert to meters\r\n    log.info(\"dist {},{},{},{}:{}\",lat1, lon1, lat2, lon2,distance);\r\n    return distance;\r\n  }\r\n\r\n  private class DistanceComparator implements Comparator<TorrentAnnounce> {\r\n\r\n    double lat, lon;\r\n\r\n    public DistanceComparator(double lat, double lon){\r\n      this.lat=lat;\r\n      this.lon=lon;\r\n    }\r\n\r\n    @Override\r\n    public int compare(TorrentAnnounce o1, TorrentAnnounce o2) {\r\n      int distance = (int)Math.round(distance(lat, lon,o1.getLatitude(),o1.getLongitude())-distance(lat, lon,o2.getLatitude(),o2.getLongitude()));\r\n      log.info(\"compare {},{}:{}\",o1.getPeerId(), o2.getPeerId(),distance);\r\n      return distance;\r\n    }\r\n  }\r\n\r\n  private String peer_id;\r\n  private String info_hash;\r\n  private String port;\r\n  private String downloaded;\r\n  private String uploaded;\r\n  private String left;\r\n  private String event;\r\n  private String compact;\r\n  private String url;\r\n  private String wallet_id;\r\n  private String liveness;\r\n  private String sign;\r\n  private String latitude;\r\n  private String longitude;\r\n\r\n  private String result;\r\n\r\n  private CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n  private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n  private Repository defaultRepo = repositoryService.findDefaultRepository();\r\n\r\n  private String projectId;\r\n\r\n  public String getResult() {\r\n    return result;\r\n  }\r\n\r\n  public void setPeer_id(String value) {\r\n    if (value.startsWith(\"0x\")) {\r\n      peer_id = value.substring(2);\r\n    } else {\r\n      peer_id = value;\r\n    }\r\n  }\r\n\r\n  public void setInfo_hash(String value) {\r\n    if (value.startsWith(\"0x\")) {\r\n      info_hash = value.substring(2);\r\n    } else {\r\n      info_hash = value;\r\n    }\r\n  }\r\n\r\n  public void setPort(String value) {\r\n    port = value;\r\n  }\r\n\r\n  public void setDownloaded(String value) {\r\n    downloaded = value;\r\n  }\r\n\r\n  public void setUploaded(String value) {\r\n    uploaded = value;\r\n  }\r\n\r\n  public void setLeft(String value) {\r\n    left = value;\r\n  }\r\n\r\n  public void setEvent(String value) {\r\n    event = value;\r\n  }\r\n\r\n  public void setCompact(String value) {\r\n    compact = value;\r\n  }\r\n\r\n  public void setUrl(String value) {\r\n    url = value;\r\n  }\r\n\r\n  @Deprecated\r\n  public void setWallet_id(String value) {\r\n    wallet_id = value;\r\n  }\r\n\r\n  public void setLiveness(String value) {\r\n    liveness = value;\r\n  }\r\n\r\n  public void setSign(String value) {\r\n    sign = value;\r\n  }\r\n\r\n  public void setLatitude(String value) {\r\n    latitude = value;\r\n  }\r\n  \r\n  public void setLongitude(String value) {\r\n    longitude = value;\r\n  }\r\n\r\n  private void parseQueryString(String qs) {\r\n    String[] params = qs.split(\"&\");\r\n    for (String param : params) {\r\n      if (param.startsWith(\"info_hash=\")) {\r\n        if (info_hash.length() != 40) {\r\n          String infoHash = param.substring(10);\r\n          try {\r\n            infoHash = URLDecoder.decode(infoHash, \"ISO-8859-1\");\r\n            info_hash = String.format(\"%x\", new BigInteger(1, infoHash.getBytes()));\r\n            log.info(\"info_hash={}\", info_hash);\r\n          } catch (Exception e) {\r\n            e.printStackTrace();\r\n          }\r\n        }\r\n      }\r\n      if (param.startsWith(\"peer_id=\")) {\r\n        if (peer_id.length() != 40) {\r\n          String peerId = param.substring(10);\r\n          try {\r\n            peerId = URLDecoder.decode(peerId, \"ISO-8859-1\");\r\n            peer_id = String.format(\"%x\", new BigInteger(1, peerId.getBytes()));\r\n            log.info(\"peer_id={}\", peer_id);\r\n          } catch (Exception e) {\r\n            e.printStackTrace();\r\n          }\r\n        }\r\n      }\r\n      if (param.startsWith(\"wallet_id=\")) {\r\n        if (wallet_id.length() != 40) {\r\n          String walletId = param.substring(10);\r\n          try {\r\n            walletId = URLDecoder.decode(walletId, \"ISO-8859-1\");\r\n            wallet_id = String.format(\"%x\", new BigInteger(1, walletId.getBytes()));\r\n            log.info(\"wallet_id={}\", wallet_id);\r\n          } catch (Exception e) {\r\n            e.printStackTrace();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public static String unHex(String arg) {\r\n\r\n    String str = \"\";\r\n    for (int i = 0; i < arg.length(); i += 2) {\r\n      String s = arg.substring(i, (i + 2));\r\n      int decimal = Integer.parseInt(s, 16);\r\n      str = str + (char) decimal;\r\n    }\r\n    return str;\r\n  }\r\n\r\n  private static Object getIdValue(Object object) {\r\n    return ReflectionUtils.getAllFields(new ArrayList<>(), object.getClass()).stream()\r\n        .filter(f -> f.getAnnotation(Id.class) != null).findFirst().map(f -> {\r\n          try {\r\n            f.setAccessible(true);\r\n            return f.get(object);\r\n          } catch (IllegalArgumentException | IllegalAccessException e) {\r\n            throw new RuntimeException(e);\r\n          }\r\n        }).orElse(null);\r\n  }\r\n\r\n  private static String getFieldForGetter(Class<?> clazz, Method getter) {\r\n    String fieldName;\r\n    if (getter.getName().startsWith(\"is\")) {\r\n      fieldName = getter.getName().substring(2);\r\n    } else {\r\n      fieldName = getter.getName().substring(3);\r\n    }\r\n\r\n    return ReflectionUtils.getAllFields(new ArrayList<>(), clazz).stream()\r\n        .filter(f -> f.getName().toUpperCase().equals(fieldName.toUpperCase())).findFirst().map(Field::getName)\r\n        .orElse(null);\r\n  }\r\n\r\n  @Override\r\n  public void execute(Map<String, Object> parameters) throws BusinessException {\r\n    // if wallet_id is set then peer_id is the device id, else the peer_id is the\r\n    // wallet_id\r\n    log.info(\r\n        \"Received announce: peer_id:{}, info_hash:{}, port:{}, downloaded:{}, uploaded:{}, left:{}, event:{}, compact:{}, wallet_id:{}, liveness:{},sign:{}\",\r\n        peer_id, info_hash, port, downloaded, uploaded, left, event, compact, wallet_id, liveness, sign);\r\n    log.info(\"Received announce: {}\", parameters);\r\n    // fix the decoding of info_hash and peer_id using correct charset in case they\r\n    // where not sent in 40 chars hexa\r\n    EndpointRequest req = (EndpointRequest) parameters.get(\"request\");\r\n    boolean outputJson = \"application/json\".equals(req.getHeader(\"Accept\"));\r\n    log.info(\"announce output json: {}\", outputJson);\r\n    if ((info_hash.length() != 40) || (peer_id.length() != 40)) {\r\n      parseQueryString(req.getQueryString());\r\n    }\r\n    wallet_id = peer_id;\r\n    // lookup wallet with id walletId\r\n    Wallet wallet = null;\r\n    try {\r\n      if (outputJson) {\r\n        result = \"{\\\"error\\\":\\\"cannot find wallet\\\"}\";\r\n      } else {\r\n        result = \"d14:failure reason27:cannot find wallet.e\";\r\n      }\r\n      wallet = crossStorageApi.find(defaultRepo, Wallet.class).by(\"hexHash\", wallet_id).getResult();\r\n    } catch (Exception e) {\r\n      throw new BusinessException(result);\r\n    }\r\n    log.info(\"found wallet {}\", wallet);\r\n\r\n    // retrieve ongoing announce\r\n    TorrentAnnounce announce = null;\r\n    List<TorrentAnnounce> announces = crossStorageApi.find(defaultRepo, TorrentAnnounce.class).by(\"peerId\",\r\n    peer_id).by(\"infoHash\", info_hash).by(\"status\", \"ONGOING\").getResults();\r\n\r\n    // events can be started,update,stopped,completed\r\n    // TODO: if announce is too old then it should be closed and a new on created\r\n    if (announces.size() > 0) {\r\n      // TODO: handle case where there is more than one announce, the old ones should\r\n      // be closed\r\n      announce = announces.get(0);\r\n    } else if (!\"stopped\".equals(event)) {\r\n      announce = new TorrentAnnounce();\r\n      announce.setPeerId(peer_id);\r\n      announce.setInfoHash(info_hash);\r\n      announce.setAnounceDate(Instant.now());\r\n    } else {\r\n      if (outputJson) {\r\n        result = \"{\\\"error\\\":\\\"cannot find announce to close\\\"}\";\r\n      } else {\r\n        result = \"d14:failure reason30:cannot find announce to close.e\";\r\n      }\r\n      throw new BusinessException(result);\r\n    }\r\n    announce.setLastAnnounceDate(Instant.now());\r\n    announce.setIp(req.getRemoteAddr());\r\n    boolean coordinateSet=true;\r\n    try {\r\n      if (!Strings.isEmpty(port)) {\r\n        announce.setPort(Long.parseLong(port));\r\n      }\r\n      if (!Strings.isEmpty(downloaded)) {\r\n        announce.setDownloaded(Long.parseLong(downloaded));\r\n      }\r\n      if (!Strings.isEmpty(uploaded)) {\r\n        announce.setUploaded(Long.parseLong(uploaded));\r\n      }\r\n      if (!Strings.isEmpty(left)) {\r\n        announce.setLeft(Long.parseLong(left));\r\n      }\r\n      if (!Strings.isEmpty(liveness)) {\r\n        announce.setLiveness(Double.parseDouble(liveness));\r\n      }\r\n      if (!Strings.isEmpty(latitude)) {\r\n        announce.setLatitude(Double.parseDouble(latitude));\r\n        if(announce.getLatitude()==0.0){\r\n          coordinateSet=false;\r\n        }\r\n      } else {\r\n        coordinateSet=false;\r\n      }\r\n      if (!Strings.isEmpty(longitude)) {\r\n        announce.setLongitude(Double.parseDouble(longitude));\r\n        if(announce.getLongitude()==0.0){\r\n          coordinateSet=false;\r\n        }\r\n      } else {\r\n        coordinateSet=false;\r\n      }\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n    }\r\n    announce.setUrl(url);\r\n    if (\"stopped\".equalsIgnoreCase(event)) {\r\n      announce.setStatus(\"CLOSED\");\r\n    } else {\r\n      announce.setStatus(\"ONGOING\");\r\n    }\r\n    try {\r\n      String uuid = crossStorageApi.createOrUpdate(defaultRepo, announce);\r\n      log.info(\"announce instance {} created / updated\", uuid);\r\n\r\n      try {\r\n        if (outputJson) {\r\n          result = \"{\\\"error\\\":\\\"cannot find peers\\\"}\";\r\n        } else {\r\n          result = \"d14:failure reason18:cannot find peers.e\";\r\n        }\r\n        CrossStorageRequest<TorrentAnnounce> csreqlist =crossStorageApi.find(defaultRepo, TorrentAnnounce.class).by(\"status\", \"ONGOING\")\r\n        .by(\"infoHash\", info_hash);\r\n        List<TorrentAnnounce> peers = csreqlist.getResults();\r\n        List<TorrentAnnounce> peersToDelete = new ArrayList<>();\r\n        for (TorrentAnnounce peer : peers) {\r\n          if(Duration.between(peer.getLastAnnounceDate(),Instant.now()).compareTo( Duration.ofMinutes( 10 ) )> 0){\r\n            peersToDelete.add(peer);\r\n          }\r\n        }\r\n        peers.removeAll(peersToDelete);\r\n        if(coordinateSet){\r\n          //order peers by increasing distance if the current announce has coordinates\r\n          DistanceComparator comp = new DistanceComparator(announce.getLatitude(),announce.getLongitude());\r\n          Collections.sort(peers,comp);\r\n        } else {\r\n          //else order peers by most recent first\r\n          peers.sort((TorrentAnnounce p1, TorrentAnnounce p2) -> p1.getLastAnnounceDate().compareTo(p2.getLastAnnounceDate()));\r\n        }\r\n        if (peers.size() > 0) {\r\n          if (outputJson) {\r\n            result = \"{\\\"interval\\\":900,\\n\\\"peers\\\":[\";\r\n          } else {\r\n            result = \"d8:intervali900e5:peersl\";\r\n          }\r\n          String sep = \"\";\r\n          for (TorrentAnnounce peer : peers) {\r\n            if(!peer.getPeerId().equals(peer_id)){\r\n              if (outputJson) {\r\n                result += sep + \"\\n\";\r\n                sep = \",\";\r\n                result += \"{\\\"peer_id\\\":\\\"\" + peer.getPeerId() + \"\\\",\\n\";\r\n                result += \" \\\"ip\\\":\\\"\" + peer.getIp() + \"\\\",\\n\";\r\n                result += \" \\\"port\\\":\" + peer.getPort() + \",\\n\";\r\n                result += \" \\\"uploaded\\\":\" + peer.getUploaded() + \",\\n\";\r\n                result += \" \\\"latitude\\\":\" + peer.getLatitude() + \",\\n\";\r\n                result += \" \\\"longitude\\\":\" + peer.getLongitude() + \",\\n\";\r\n                result += \" \\\"liveness\\\":\" + peer.getLiveness() + \"}\";\r\n              } else {\r\n                String peerid = unHex(peer.getPeerId());\r\n                result += \"d7:peer_id\" + peerid.length() + \":\" + peerid;\r\n                result += \"2:ip\" + peer.getIp().length() + \":\" + peer.getIp();\r\n                result += \"4:port\" + (peer.getPort() + \"\").length() + \":i\" + peer.getPort() + \"ee\";\r\n              }\r\n            }\r\n          }\r\n          if (outputJson) {\r\n            result += \"]}\";\r\n          } else {\r\n            result += \"e\";\r\n          }\r\n        }\r\n        if (peersToDelete.size() > 0) {\r\n          for(TorrentAnnounce peer : peersToDelete){\r\n            try{\r\n              crossStorageApi.remove(defaultRepo,  peer.getUuid(),TorrentAnnounce.class);\r\n            } catch(Exception e){\r\n              e.printStackTrace();\r\n            }\r\n          }\r\n        }\r\n      } catch (Exception e) {\r\n        throw new BusinessException(result);\r\n      }\r\n    } catch (Exception ex) {\r\n      throw new BusinessException(ex);\r\n    }\r\n    \r\n  }\r\n\r\n}",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ {
    "groupId" : "org.web3j",
    "artifactId" : "core",
    "version" : "4.8.9",
    "coordinates" : "org.web3j:core:4.8.9"
  } ],
  "importScriptInstances" : [ ]
}